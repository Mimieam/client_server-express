{"ts":1351811681588,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"extends layout\n\nblock content\n  h2 Schemas\n  :markdown\n    If you haven't yet done so, please take a minute to read the [quickstart](./index.html) to get an idea of how Mongoose works.\n  :markdown\n    If you are migrating from 2.x to 3.x please take a moment to read the [migration guide](./migration.html).\n  :markdown\n    This page covers `Schema` [definition](#definition), [plugins](#plugins), instance [methods](#methods), [statics](#statics), [indexes](#indexes), [virtuals](#virtuals) and [options](#options). Let's start with `Schema` definition.\n  h3#definition Defining your schema\n  p\n    | Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.\n  :js\n    var blogSchema = new Schema({\n      title:  String,\n      author: String,\n      body:   String,\n      comments: [{ body: String, date: Date }],\n      date: { type: Date, default: Date.now },\n      hidden: Boolean,\n      meta: {\n        votes: Number,\n        favs:  Number\n      }\n    });\n  p\n    em\n      | If you want to add additional keys later, use the \n      a(href=\"./api.html#schema_Schema-add\") Schema#add\n      |  method.\n  p \n    | Each key in our \n    code blogSchema\n    |  defines a property in our documents which will be cast to its associated \n    a(href=\"./api.html#schematype_SchemaType\") SchemaType\n    |.  For example, we've defined a \n    code title\n    |  which will be cast to the \n    a(href=\"./api.html#schema-string-js\") String\n    |  SchemaType and \n    code date\n    |  which will be cast to a \n    code Date\n    |  SchemaType.\n    | Keys may also be assigned nested objects containing further key/type definitions \n    em (e.g. the `meta` property above).\n  p\n    | The permitted SchemaTypes are \n    ul\n      li String\n      li Number\n      li Date\n      li Buffer\n      li Boolean\n      li Mixed\n      li ObjectId\n      li Array\n    | Read more about them \n    a(href=\"./schematypes.html\") here\n    | .\n  p\n    | Schemas not only define the structure of your document and casting of properties, they also define document \n    a(href=\"#methods\") instance methods\n    |, static \n    a(href=\"#statics\") Model methods\n    |, \n    a(href=\"#indexes\") compound indexes\n    |  and document lifecycle hooks called \n    a(href=\"./middleware.html\") middleware\n    |.\n  h3#plugins Pluggable\n  p\n    | Schemas are \n    a(href=\"./plugins.html\") pluggable\n    |  which allows us to package up reusable features into \n    a(href=\"http://plugins.mongoosejs.com\") plugins\n    |  that can be shared with the community or just between your projects.\n  h3#methods Instance methods\n  p \n    a(href=\"./models.html\") Models\n    |  are just fancy \n    code constructor\n    |  functions. As such they can have prototype methods inherited by their instances. In the case of Mongoose, instances are \n    a(href=\"./documents.html\") documents\n    |.\n  p\n    | Defining an instance method is easy.\n  :js\n    var animalSchema = new Schema({ name: String, type: String });\n\n    animalSchema.methods.findSimilarTypes = function (cb) {\n      return this.model('Animal').find({ type: this.type }, cb);\n    }\n  p\n    | Now all of our \n    code animal\n    |  instances have a \n    code findSimilarTypes\n    |  method available to it.\n  :js\n    var Animal = mongoose.model('Animal', animalSchema);\n    var dog = new Animal({ type: 'dog' });\n\n    dog.findSimilarTypes(function (err, dogs) {\n      console.log(dogs); // woof\n    });\n  h3#statics Statics\n  p \n    | Adding static constructor methods to Models is simple as well. Continuing with our \n    code animalSchema\n    |:\n  :js\n    animalSchema.statics.findByName = function (name, cb) {\n      this.find({ name: new RegExp(name, 'i') }, cb);\n    }\n\n    var Animal = mongoose.model('Animal', animalSchema);\n    Animal.findByName('fido', function (err, animals) {\n      console.log(animals);\n    });\n  h3#indexes Indexes\n  p\n    a(href=\"http://www.mongodb.org/display/DOCS/Indexes\") Indexes\n    |  can be defined \n    a(href=\"./api.html#schematype_SchemaType-index\") at\n    | \n    a(href=\"./api.html#schematype_SchemaType-unique\") the\n    | \n    a(href=\"./api.html#schematype_SchemaType-sparse\") path\n    | \n    a(href=\"./api.html#schematype_SchemaType-expires\") level\n    |  or the \n    code schema\n    |  level. Defining indexes at the schema level is necessary when defining \n    a(href=\"http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeys\", target=\"_blank\") compound indexes\n    |.\n  :js\n    animalSchema.index({ name: 1, type: -1 });\n\n  :markdown\n    When your application starts up, Mongoose automatically calls `ensureIndex` for each defined index. It is recommended this behavior be disabled in production by setting the `autoIndex` option of your schema to `false`.\n\n  :js\n    animalSchema.set('autoIndex', false);\n    // or\n    new Schema({..}, { autoIndex: false });\n\n  p\n    | See also the \n    a(href=\"./api.html#model_Model-ensureIndexes\")\n      code Model#ensureIndexes\n    |  method for more details.\n\n  h3#virtuals Virtuals\n  :markdown\n    [Virtual](./api.html#schema_Schema-virtual) attributes are attributes that are convenient to have around but that do not get persisted to MongoDB.\n  :js\n    var personSchema = new Schema({\n      name: {\n        first: String,\n        last: String\n      }\n    });\n\n    var Person = mongoose.model('Person', personSchema);\n\n    var bad = new Person({\n        name: { first: 'Walter', last: 'White' }\n    });\n  :markdown\n    Suppose we want to log the full name of `bad`. We could do this manually like so:\n  :js\n    console.log(bad.name.first + ' ' + bad.name.last); // Walter White\n  :markdown\n    Or we could add a `virtual` attribute [getter](./api.html#virtualtype_VirtualType-get) to our `personSchema` so we don't need to write out this string concatenation mess each time:\n  :js\n    personSchema.virtual('name.full').get(function () {\n      return this.name.first + ' ' + this.name.last;\n    });\n  :markdown\n    Now, when we access our virtual full name property, our getter function will be invoked and the value returned:\n  :js\n    console.log('%s is insane', bad.name.full); // Walter White is insane\n  :markdown\n    It would also be nice to be able to set `this.name.first` and `this.name.last` by setting `this.name.full`. For example, if we wanted to change `bad`'s `name.first` and `name.last` to 'Breaking' and 'Bad' respectively, it'd be nice to just:\n  :js\n    bad.name.full = 'Breaking Bad';\n  :markdown\n    Mongoose let's you do this as well through its virtual attribute [setters](./api.html#virtualtype_VirtualType-set):\n  :js\n    personSchema.virtual('name.full').set(function (name) {\n      var split = name.split(' ');\n      this.name.first = split[0];\n      this.name.last = split[1];\n    });\n\n    ...\n\n    mad.name.full = 'Breaking Bad';\n    console.log(mad.name.first); // Breaking\n  :markdown\n    If you need attributes that you can get and set but that are not themselves persisted to MongoDB, virtual attributes is the Mongoose feature for you.\n\n  h3#options Options\n  :markdown\n    `Schema`s have a few configurable options which can be passed to the constructor or `set` directly:\n  :js\n    new Schema({..}, options);\n\n    // or\n\n    var schema = new Schema({..});\n    schema.set(option, value);\n\n  :markdown\n    Valid options:\n\n    - [autoIndex](#autoIndex)\n    - [capped](#capped)\n    - [id](#id)\n    - [_id](#_id)\n    - [read](#read)\n    - [safe](#safe)\n    - [shardKey](#shardKey)\n    - [strict](#strict)\n    - [toJSON](#toJSON)\n    - [toObject](#toObject)\n    - [versionKey](#versionKey)\n\n  h4#autoIndex option: autoIndex\n  :markdown\n    At application startup, Mongoose sends an `ensureIndex` command for each index declared in your `Schema`. As of Mongoose v3, indexes are created in the `background` by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your `Schema`s `autoIndex` option to `false` and use the [ensureIndexes](./api.html#model_Model-ensureIndexes) method on your model.\n  :js\n    var schema = new Schema({..}, { autoIndex: false });\n    var Clock = db.model('Clock', schema);\n    Clock.ensureIndexes(callback);\n\n  h4#capped option: capped\n  :markdown\n    Mongoose supports MongoDBs [capped](http://www.mongodb.org/display/DOCS/Capped+Collections) collections. To specify the underlying MongoDB collection be `capped`, set the `capped` option to the maximum size of the collection in [bytes](http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-size.).\n  :js\n    new Schema({..}, { capped: 1024 });\n  :markdown\n    The `capped` option may also be set to an object if you want to pass additional options like [max](http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-max) or [autoIndexId](http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-autoIndexId). In this case you must explicitly pass the `size` option which is required.\n  :js\n    new Schema({..}, { capped: { size: 1024, max: 1000, autoIndexId: true } });\n\n  h4#id option: id\n  :markdown\n    Mongoose assigns each of your schemas an `id` virtual getter by default which returns the documents `_id` field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an `id` getter added to your schema, you may disable it passing this option at schema construction time.\n  :js\n    // default behavior\n    var schema = new Schema({ name: String });\n    var Page = db.model('Page', schema);\n    var p = new Page({ name: 'mongodb.org' });\n    console.log(p.id); // '50341373e894ad16347efe01'\n\n    // disabled id\n    var schema = new Schema({ name: String }, { id: false });\n    var Page = db.model('Page', schema);\n    var p = new Page({ name: 'mongodb.org' });\n    console.log(p.id); // undefined\n\n  h4#_id option: _id\n  :markdown\n    Mongoose assigns each of your schemas an `_id` field by default if one is not passed into the [Schema](/docs/api.html#schema-js) constructor. The type assiged is an [ObjectId](/docs/api.html#schema_Schema-Types) to coincide with MongoDBs default behavior. If you don't want an `_id` added to your schema at all, you may disable it using this option.\n\n    Pass this option during schema construction to prevent documents from getting an auto `_id` created.\n  :js\n    // default behavior\n    var schema = new Schema({ name: String });\n    var Page = db.model('Page', schema);\n    var p = new Page({ name: 'mongodb.org' });\n    console.log(p); // { _id: '50341373e894ad16347efe01', name: 'mongodb.org' }\n\n    // disabled _id\n    var schema = new Schema({ name: String }, { _id: false });\n    var Page = db.model('Page', schema);\n    var p = new Page({ name: 'mongodb.org' });\n    console.log(p); // { name: 'mongodb.org' }\n\n  h4#read option: read\n  :markdown\n    Allows setting [query#read](/docs/api.html#query_Query-read) options at the schema level, providing us a way to apply default [ReadPreferences](http://docs.mongodb.org/manual/applications/replication/#replica-set-read-preference) to all queries derived from a model.\n\n  :js\n    var schema = new Schema({..}, { read: 'primary' });            // also aliased as 'p'\n    var schema = new Schema({..}, { read: 'primaryPreferred' });   // aliased as 'pp'\n    var schema = new Schema({..}, { read: 'secondary' });          // aliased as 's'\n    var schema = new Schema({..}, { read: 'secondaryPreferred' }); // aliased as 'sp'\n    var schema = new Schema({..}, { read: 'nearest' });            // aliased as 'n'\n\n  :markdown\n    The alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.\n\n    The read option also allows us to specify _tag sets_. These tell the [driver](https://github.com/mongodb/node-mongodb-native/) from which members of the replica-set it should attempt to read. Read more about tag sets [here](http://docs.mongodb.org/manual/applications/replication/#tag-sets) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n\n    _NOTE: if you specify the read pref 'nearest', you must also pass the [strategy](http://mongodb.github.com/node-mongodb-native/api-generated/replset.html?highlight=strategy) option when connecting or your reads will not behave predictably:_\n\n  :js\n    // pings the replset members periodically to track network latency\n    // now `nearest` works as intended\n    var options = { replset: { strategy: 'ping' }};\n    mongoose.connect(uri, options);\n\n    var schema = new Schema({..}, { read: ['n', { disk: 'ssd' }] });\n    mongoose.model('JellyBean', schema);\n\n  h4#safe option: safe\n  :markdown\n    This option is passed to MongoDB with all operations and let's us specify if errors should be returned to our callbacks as well as tune write behavior.\n\n  :js\n    var safe = true;\n    new Schema({ .. }, { safe: safe });\n\n  :markdown\n    By default this is set to `true` for all schemas which guarentees that any occurring error gets passed back to our callback.\n    By setting `safe` to something else like `{ j: 1, w: 2, wtimeout: 10000 }` we can guarantee the write was committed to the MongoDB journal (j: 1), at least 2 replicas (w: 2), and that the write will timeout if it takes longer than 10 seconds (wtimeout: 10000). Errors will still be passed to our callback.\n\n    There are other write concerns like `{ w: \"majority\" }` too. See the MongoDB [docs](http://www.mongodb.org/display/DOCS/getLastError+Command) for more details.\n\n  :js\n    var safe = { w: \"majority\", wtimeout: 10000 };\n    new Schema({ .. }, { safe: safe });\n\n  h4#shardKey option: shardKey\n  :markdown\n    The `shardKey` option is used when we have a [sharded MongoDB architecture](http://www.mongodb.org/display/DOCS/Sharding+Introduction). Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and weâ€™ll be all set.\n\n  :js\n    new Schema({ .. }, { shardkey: { tag: 1, name: 1 }})\n\n  :markdown\n    _Note that Mongoose does not send the `shardcollection` command for you. You must configure your shards yourself._\n\n  h4#strict option: strict\n  :markdown\n    The strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.\n\n  :js\n    var thingSchema = new Schema({..})\n    var Thing = db.model('Thing', schemaSchema);\n    var thing = new Thing({ iAmNotInTheSchema: true });\n    thing.save(); // iAmNotInTheSchema is not saved to the db\n\n    // set to false..\n    var thingSchema = new Schema({..}, { strict: false });\n    var thing = new Thing({ iAmNotInTheSchema: true });\n    thing.save(); // iAmNotInTheSchema is now saved to the db!!\n\n  :markdown\n    This also affects the use of `doc.set()` to set a property value.\n\n  :js\n    var thingSchema = new Schema({..})\n    var Thing = db.model('Thing', schemaSchema);\n    var thing = new Thing;\n    thing.set('iAmNotInTheSchema', true);\n    thing.save(); // iAmNotInTheSchema is not saved to the db\n\n  :markdown\n    This value can be overridden at the model instance level by passing a second boolean argument:\n\n  :js\n    var Thing = db.model('Thing');\n    var thing = new Thing(doc, true);  // enables strict mode\n    var thing = new Thing(doc, false); // disables strict mode\n\n  :markdown\n    The `strict` option may also be set to `\"throw\"` which will cause errors to be produced instead of dropping the bad data.\n\n  :markdown\n    _NOTE: do not set to false unless you have good reason._\n\n    _NOTE: in mongoose v2 the default was false._\n\n    _NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option._\n\n  :js\n    var thingSchema = new Schema({..})\n    var Thing = db.model('Thing', schemaSchema);\n    var thing = new Thing;\n    thing.iAmNotInTheSchema = true;\n    thing.save(); // iAmNotInTheSchema is never saved to the db\n\n  h4#toJSON option: toJSON\n  :markdown\n    Exactly the same as the [toObject](#toObject) option but only applies when the documents `toJSON` method is called.\n  :js\n    var schema = new Schema({ name: String });\n    schema.path('name').get(function (v) {\n      return v + ' is my name';\n    });\n    schema.set('toJSON', { getters: true, virtuals: false });\n    var M = mongoose.model('Person', schema);\n    var m = new M({ name: 'Max Headroom' });\n    console.log(m.toObject()); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }\n    console.log(m.toJSON()); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }\n    // since we know toJSON is called whenever a js object is stringified:\n    console.log(JSON.stringify(m)); // { \"_id\": \"504e0cd7dd992d9be2f20b6f\", \"name\": \"Max Headroom is my name\" }\n\n  h4#toObject option: toObject\n  :markdown\n    Documents have a [toObject](/docs/api.html#document_Document-toObject) method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default.\n\n    To have all virtuals show up in your `console.log` output, set the `toObject` option to `{ getters: true }`:\n\n  :js\n    var schema = new Schema({ name: String });\n    schema.path('name').get(function (v) {\n      return v + ' is my name';\n    });\n    schema.set('toObject', { getters: true });\n    var M = mongoose.model('Person', schema);\n    var m = new M({ name: 'Max Headroom' });\n    console.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }\n\n  h4#versionKey option: versionKey\n  :markdown\n    The `versionKey` is a property set on each document when first created by Mongoose. This keys value contains the internal [revision](http://aaronheckmann.posterous.com/mongoose-v3-part-1-versioning) of the document. The name of this document property is configurable. The default is `__v`. If this conflicts with your application you can configure as such:\n  :js\n    var schema = new Schema({ name: 'string' });\n    var Thing = db.model('Thing', schema);\n    var thing = new Thing({ name: 'mongoose v3' });\n    thing.save(); // { __v: 0, name: 'mongoose v3' }\n\n    // customized versionKey\n    new Schema({..}, { versionKey: '_somethingElse' })\n    var Thing = db.model('Thing', schema);\n    var thing = new Thing({ name: 'mongoose v3' });\n    thing.save(); // { _somethingElse: 0, name: 'mongoose v3' }\n\n  :markdown\n    Document versioning can also be disabled by setting the `versionKey` to false. _DO NOT disable versioning unless you [know what you are doing](http://aaronheckmann.posterous.com/mongoose-v3-part-1-versioning)._\n  :js\n    new Schema({..}, { versionKey: false });\n    var Thing = db.model('Thing', schema);\n    var thing = new Thing({ name: 'no versioning please' });\n    thing.save(); // { name: 'no versioning please' }\n\n\n  h3#next Next Up\n  :markdown\n    Now that we've covered `Schemas`, let's take a look at [SchemaTypes](/docs/schematypes.html).\n\nscript.\ndocument.body.className = 'load';\ninclude includes/googleanalytics\n"]],"start1":0,"start2":0,"length1":0,"length2":19221}]],"length":19221}
