{"ts":1351811702004,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Module dependencies\n */\n\nvar fs = require('fs');\nvar link = require('../helpers/linktype');\nvar hl = require('highlight.js')\nvar md = require('markdown')\n\nmodule.exports = {\n    docs: []\n  , github: 'https://github.com/LearnBoost/mongoose/tree/'\n  , title: 'API docs'\n}\n\nvar out = module.exports.docs;\n\nvar docs = fs.readFileSync(__dirname + '/_docs', 'utf8');\nparse(docs);\norder(out);\n\nfunction parse (docs) {\n  docs.split(/^### /gm).forEach(function (chunk) {\n    if (!(chunk = chunk.trim())) return;\n\n    chunk = chunk.split(/^([^\\n]+)\\n/);\n\n    var title = chunk[1];\n\n    if (!title || !(title = title.trim()))\n      throw new Error('missing title');\n\n    title = title.replace(/^lib\\//, '');\n\n    var json = JSON.parse(chunk[2]);\n\n    var props = [];\n    var methods = [];\n    var statics = [];\n    var constructor = null;\n\n    json.forEach(function (comment) {\n      if (comment.description)\n        highlight(comment.description);\n\n      var prop = false;\n      comment.params = [];\n      comment.see = [];\n\n      var i = comment.tags.length;\n      while (i--) {\n        var tag = comment.tags[i];\n        switch (tag.type) {\n        case 'property':\n          prop = true;\n          comment.ctx || (comment.ctx = {});\n          comment.ctx.name = tag.string;\n          props.unshift(comment);\n          break;\n        case 'method':\n          prop = false;\n          comment.ctx || (comment.ctx = {});\n          comment.ctx.name || (comment.ctx.name = tag.string);\n          comment.ctx.type = 'method';\n          comment.code = '';\n          break;\n        case 'memberOf':\n          prop = false;\n          comment.ctx || (comment.ctx = {});\n          comment.ctx.constructor = tag.parent;\n          break;\n        case 'static':\n          prop = false;\n          comment.ctx || (comment.ctx = {});\n          comment.ctx.name = tag.string;\n          comment.ctx.type = 'method';\n          break;\n        case 'receiver':\n          prop = false;\n          comment.ctx || (comment.ctx = {});\n          comment.ctx.receiver = tag.string;\n          break;\n        case 'constructor':\n          prop = false;\n          comment.ctx || (comment.ctx = {});\n          comment.ctx.name || (comment.ctx.name = tag.string);\n          comment.ctx.type = 'function';\n          comment.code = '';\n          break;\n        case 'inherits':\n          if (/http/.test(tag.string)) {\n            var result = tag.string.split(' ');\n            var href = result.pop();\n            var title = result.join(' ');\n            comment.inherits = '<a href=\"'\n                     + href\n                     + '\" title=\"' + title + '\">' + title + '</a>';\n          } else {\n            comment.inherits = link(tag.string);\n          }\n          comment.tags.splice(i, 1);\n          break;\n        case 'param':\n          comment.params.unshift(tag);\n          comment.tags.splice(i, 1);\n          break;\n        case 'return':\n          comment.return = tag;\n          comment.tags.splice(i, 1);\n          break;\n        case 'see':\n          if (tag.local) {\n            var parts = tag.local.split(' ');\n            if (1 === parts.length) {\n              tag.url = link.type(parts[0]);\n              tag.title = parts[0];\n            } else {\n              tag.url = parts.pop();\n              tag.title = parts.join(' ');\n            }\n          }\n          comment.see.unshift(tag);\n          comment.tags.splice(i, 1);\n          break;\n        case 'event':\n          var str = tag.string.replace(/\\\\n/g, '\\n');\n          tag.string = md.parse(str).replace(/\\n/g, '\\\\n').replace(/'/g, '&#39;');\n          comment.events || (comment.events = []);\n          comment.events.unshift(tag);\n          comment.tags.splice(i, 1);\n        }\n      }\n\n      if (!prop) {\n        methods.push(comment);\n      }\n    });\n\n    methods = methods.filter(ignored);\n    props = props.filter(ignored);\n\n    function ignored (method) {\n      if (method.ignore) return false;\n      return true;\n    }\n\n    if (0 === methods.length + props.length) return;\n\n    // add constructor to properties too\n    methods.some(function (method) {\n      if (method.ctx && 'method' == method.ctx.type && method.ctx.hasOwnProperty('constructor')) {\n        props.forEach(function (prop) {\n          prop.ctx.constructor = method.ctx.constructor;\n        });\n        return true;\n      }\n      return false;\n    });\n\n    var len = methods.length;\n    while (len--) {\n      method = methods[len];\n      if (method.ctx && method.ctx.receiver) {\n        var stat = methods.splice(len, 1)[0];\n        statics.unshift(stat);\n      }\n    }\n\n    out.push({\n        title: title\n      , methods: methods\n      , props: props\n      , statics: statics\n      , hasPublic: hasPublic(methods, props, statics)\n    });\n  });\n}\n\nfunction hasPublic () {\n  for (var i = 0; i < arguments.length; ++i) {\n    var arr = arguments[i];\n    for (var j = 0; j < arr.length; ++j) {\n      var item = arr[j];\n      if (!item.ignore && !item.isPrivate) return true;\n    }\n  }\n  return false;\n}\n\n// add \"class='language'\" to our <pre><code> elements\nfunction highlight (o) {\n  o.full = fix(o.full);\n  o.summary = fix(o.summary);\n  o.body = fix(o.body);\n}\n\nfunction fix (str) {\n  return str.replace(/(<pre><code>)([^<]+)(<\\/code)/gm, function (_, $1, $2, $3) {\n\n    // parse out the ```language\n    var code = /^(?:`{3}([^\\n]+)\\n)?([\\s\\S]*)/gm.exec($2);\n\n    if ('js' == code[1] || !code[1]) {\n      code[1] = 'javascript';\n    }\n\n    return $1\n          + hl.highlight(code[1], code[2]).value.trim()\n          + $3;\n  });\n}\n\nfunction order (docs) {\n  // want index first\n  for (var i = 0; i < docs.length; ++i) {\n    if ('index.js' == docs[i].title) {\n      docs.unshift(docs.splice(i, 1)[0]);\n    }\n  }\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":5735}]],"length":5735}
