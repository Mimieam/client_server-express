{"ts":1352708399229,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/**\n * Module dependencies.\n */\n\nvar start = require('./common')\n  , mongoose = start.mongoose\n  , Schema = mongoose.Schema\n  , utils = require('../lib/utils')\n  , StateMachine = require('../lib/statemachine')\n  , ObjectId = require('../lib/types/objectid')\n  , MongooseBuffer = require('../lib/types/buffer')\n  , ReadPref = mongoose.mongo.ReadPreference\n  , assert = require('assert')\n\n/**\n * Setup.\n */\n\nvar ActiveRoster = StateMachine.ctor('require', 'init', 'modify');\n\n/**\n * Test.\n */\n\ndescribe('utils', function(){\n  it('should detect a path as required if it has been required', function () {\n    var ar = new ActiveRoster();\n    ar.require('hello');\n    assert.equal(ar.paths['hello'],'require');\n  })\n\n  it('should detect a path as inited if it has been inited', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    assert.equal(ar.paths['hello'],'init');\n  })\n\n  it('should detect a path as modified', function () {\n    var ar = new ActiveRoster();\n    ar.modify('hello');\n    assert.equal(ar.paths['hello'],'modify');\n  })\n\n  it('should remove a path from an old state upon a state change', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.modify('hello');\n    assert.ok(!ar.states.init.hasOwnProperty('hello'));\n    assert.ok(ar.states.modify.hasOwnProperty('hello'));\n  })\n\n  it('forEach should be able to iterate through the paths belonging to one state', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.init('goodbye');\n    ar.modify('world');\n    ar.require('foo');\n    ar.forEach('init', function (path) {\n      assert.ok(~['hello', 'goodbye'].indexOf(path));\n    });\n  })\n\n  it('forEach should be able to iterate through the paths in the union of two or more states', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.init('goodbye');\n    ar.modify('world');\n    ar.require('foo');\n    ar.forEach('modify', 'require', function (path) {\n      assert.ok(~['world', 'foo'].indexOf(path));\n    });\n  })\n\n  it('forEach should iterate through all paths that have any state if given no state arguments', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.init('goodbye');\n    ar.modify('world');\n    ar.require('foo');\n    ar.forEach(function (path) {\n      assert.ok(~['hello', 'goodbye','world', 'foo'].indexOf(path));\n    });\n  })\n\n  it('should be able to detect if at least one path exists in a set of states', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.modify('world');\n    assert.ok(ar.some('init'));\n    assert.ok(ar.some('modify'));\n    assert.ok(!ar.some('require'));\n    assert.ok(ar.some('init', 'modify'));\n    assert.ok(ar.some('init', 'require'));\n    assert.ok(ar.some('modify', 'require'));\n  })\n\n  it('should be able to `map` over the set of paths in a given state', function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.modify('world');\n    ar.require('iAmTheWalrus');\n    var suffixedPaths = ar.map('init', 'modify', function (path) {\n      return path + '-suffix';\n    });\n    assert.deepEqual(suffixedPaths,['hello-suffix', 'world-suffix']);\n  })\n\n  it(\"should `map` over all states' paths if no states are specified in a `map` invocation\", function () {\n    var ar = new ActiveRoster();\n    ar.init('hello');\n    ar.modify('world');\n    ar.require('iAmTheWalrus');\n    var suffixedPaths = ar.map(function (path) {\n      return path + '-suffix';\n    });\n    assert.deepEqual(suffixedPaths,['iAmTheWalrus-suffix', 'hello-suffix', 'world-suffix']);\n  })\n\n  it('test utils.options', function () {\n    var o = { a: 1, b: 2, c: 3, 0: 'zero1' };\n    var defaults = { b: 10, d: 20, 0: 'zero2' };\n    var result = utils.options(defaults, o);\n    assert.equal(1, result.a);\n    assert.equal(result.b,2);\n    assert.equal(result.c,3);\n    assert.equal(result.d,20);\n    assert.deepEqual(o.d,result.d);\n    assert.equal(result['0'],'zero1');\n\n    var result2 = utils.options(defaults);\n    assert.equal(result2.b, 10);\n    assert.equal(result2.d, 20);\n    assert.equal(result2['0'], 'zero2');\n\n    // same properties/vals\n    assert.deepEqual(defaults, result2);\n\n    // same object\n    assert.notEqual(defaults, result2);\n  })\n\n  it('test deepEquals on ObjectIds', function () {\n    var s = (new ObjectId).toString();\n\n    var a = new ObjectId(s)\n      , b = new ObjectId(s);\n\n    assert.ok(utils.deepEqual(a, b));\n    assert.ok(utils.deepEqual(a, a));\n    assert.ok(!utils.deepEqual(a, new ObjectId));\n  })\n\n  it('deepEquals on MongooseDocumentArray works', function () {\n    var db = start()\n      , A = new Schema({ a: String })\n      , M = db.model('deepEqualsOnMongooseDocArray', new Schema({\n            a1: [A]\n          , a2: [A]\n        }));\n\n    db.close();\n\n    var m1 = new M({\n        a1: [{a: 'Hi'}, {a: 'Bye'}]\n    });\n\n    m1.a2 = m1.a1;\n    assert.ok(utils.deepEqual(m1.a1, m1.a2));\n\n    var m2 = new M;\n    m2.init(m1.toObject());\n\n    assert.ok(utils.deepEqual(m1.a1, m2.a1));\n\n    m2.set(m1.toObject());\n    assert.ok(utils.deepEqual(m1.a1, m2.a1))\n  })\n\n  // gh-688\n  it('deepEquals with MongooseBuffer', function () {\n    var str = \"this is the day\";\n    var a = new MongooseBuffer(str);\n    var b = new MongooseBuffer(str);\n    var c = new Buffer(str);\n    var d = new Buffer(\"this is the way\");\n    var e = new Buffer(\"other length\");\n\n    assert.ok(utils.deepEqual(a, b))\n    assert.ok(utils.deepEqual(a, c))\n    assert.ok(!utils.deepEqual(a, d))\n    assert.ok(!utils.deepEqual(a, e))\n    assert.ok(!utils.deepEqual(a, []))\n    assert.ok(!utils.deepEqual([], a))\n  })\n\n  it('#readPref', function(){\n    var r = utils.readPref('p');\n    assert.equal('primary', r.mode);\n    var r = utils.readPref('primary');\n    assert.equal('primary', r.mode);\n\n    var r = utils.readPref('pp');\n    assert.equal('primaryPrefered', r.mode);\n    var r = utils.readPref('primaryPrefered');\n    assert.equal('primaryPrefered', r.mode);\n\n    var r = utils.readPref('s');\n    assert.equal('secondary', r.mode);\n    var r = utils.readPref('secondary');\n    assert.equal('secondary', r.mode);\n\n    var r = utils.readPref('sp');\n    assert.equal('secondaryPrefered', r.mode);\n    var r = utils.readPref('secondaryPrefered');\n    assert.equal('secondaryPrefered', r.mode);\n\n    var r = utils.readPref('n');\n    assert.equal('nearest', r.mode);\n    var r = utils.readPref('nearest');\n    assert.equal('nearest', r.mode);\n\n    var r = utils.readPref('explode');\n    assert.equal(false, r.isValid(r.model));\n  })\n})\n\n"]],"start1":0,"start2":0,"length1":0,"length2":6519}]],"length":6519}
