{"ts":1352714246156,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/**\n * Test dependencies.\n */\n\nvar start = require('./common')\n  , assert = require('assert')\n  , mongoose = start.mongoose\n  , random = require('../lib/utils').random\n  , Query = require('../lib/query')\n  , Schema = mongoose.Schema\n  , SchemaType = mongoose.SchemaType\n  , CastError = SchemaType.CastError\n  , ValidatorError = SchemaType.ValidatorError\n  , ValidationError = mongoose.Document.ValidationError\n  , ObjectId = Schema.ObjectId\n  , DocumentObjectId = mongoose.Types.ObjectId\n  , DocumentArray = mongoose.Types.DocumentArray\n  , EmbeddedDocument = mongoose.Types.Embedded\n  , MongooseArray = mongoose.Types.Array\n  , MongooseError = mongoose.Error;\n\n/**\n * Setup.\n */\n\nvar Comments = new Schema;\n\nComments.add({\n    title     : String\n  , date      : Date\n  , body      : String\n  , comments  : [Comments]\n});\n\nvar BlogPost = new Schema({\n    title     : String\n  , author    : String\n  , slug      : String\n  , date      : Date\n  , meta      : {\n        date      : Date\n      , visitors  : Number\n    }\n  , published : Boolean\n  , mixed     : {}\n  , numbers   : [Number]\n  , owners    : [ObjectId]\n  , comments  : [Comments]\n  , nested    : { array: [Number] }\n});\n\nBlogPost\n.virtual('titleWithAuthor')\n.get(function () {\n  return this.get('title') + ' by ' + this.get('author');\n})\n.set(function (val) {\n  var split = val.split(' by ');\n  this.set('title', split[0]);\n  this.set('author', split[1]);\n});\n\nBlogPost.method('cool', function(){\n  return this;\n});\n\nBlogPost.static('woot', function(){\n  return this;\n});\n\nmongoose.model('BlogPost', BlogPost);\n\nvar collection = 'blogposts_' + random();\n\ndescribe('model', function(){\n  describe('constructor', function(){\n    it('works without \"new\" keyword', function(){\n      var B = mongoose.model('BlogPost');\n      var b = B();\n      assert.ok(b instanceof B);\n      var db = start();\n      B = db.model('BlogPost');\n      db.close();\n      b = B();\n      assert.ok(b instanceof B);\n    })\n    it('works \"new\" keyword', function(){\n      var B = mongoose.model('BlogPost');\n      var b = new B();\n      assert.ok(b instanceof B);\n      var db = start();\n      B = db.model('BlogPost');\n      db.close();\n      b = new B();\n      assert.ok(b instanceof B);\n    })\n  })\n  describe('isNew', function(){\n    it('is true on instantiation', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      db.close();\n      var post = new BlogPost;\n      assert.equal(true, post.isNew);\n    });\n\n    it('on parent and subdocs on failed inserts', function(done){\n      var db = start()\n\n      var schema = new Schema({\n          name: { type: String, unique: true }\n        , em: [new Schema({ x: Number })]\n      }, { collection: 'testisnewonfail_'+random() });\n\n      var A = db.model('isNewOnFail', schema);\n\n      A.on('index', function () {\n        var a = new A({ name: 'i am new', em: [{ x: 1 }] });\n        a.save(function (err) {\n          assert.ifError(err);\n          assert.equal(a.isNew, false);\n          assert.equal(a.em[0].isNew, false);\n          var b = new A({ name: 'i am new', em: [{x:2}] });\n          b.save(function (err) {\n            db.close();\n            assert.ok(err);\n            assert.equal(b.isNew, true);\n            assert.equal(b.em[0].isNew, true);\n            done();\n          });\n        });\n      });\n    })\n  });\n\n  describe('schema', function(){\n    it('should exist', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      db.close();\n      assert.ok(BlogPost.schema instanceof Schema);\n      assert.ok(BlogPost.prototype.schema instanceof Schema);\n    });\n    it('emits init event', function(){\n      var db = start()\n        , schema = new Schema({ name: String })\n        , model\n\n      schema.on('init', function (model_) {\n        model = model_;\n      });\n\n      var Named = db.model('EmitInitOnSchema', schema);\n      db.close();\n      assert.equal(model,Named);\n    });\n  });\n\n  describe('structure', function(){\n    it('default when instantiated', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      db.close();\n      var post = new BlogPost;\n      assert.equal(post.db.model('BlogPost').modelName,'BlogPost');\n      assert.equal(post.constructor.modelName,'BlogPost');\n\n      assert.ok(post.get('_id') instanceof DocumentObjectId);\n\n      assert.equal(undefined, post.get('title'));\n      assert.equal(undefined, post.get('slug'));\n      assert.equal(undefined, post.get('date'));\n\n      assert.equal('object', typeof post.get('meta'));\n      assert.deepEqual(post.get('meta'), {});\n      assert.equal(undefined, post.get('meta.date'));\n      assert.equal(undefined, post.get('meta.visitors'));\n      assert.equal(undefined, post.get('published'));\n      assert.equal(1, Object.keys(post.get('nested')).length);\n      assert.ok(Array.isArray(post.get('nested').array));\n\n      assert.ok(post.get('numbers') instanceof MongooseArray);\n      assert.ok(post.get('owners') instanceof MongooseArray);\n      assert.ok(post.get('comments') instanceof DocumentArray);\n      assert.ok(post.get('nested.array') instanceof MongooseArray);\n    });\n\n    describe('array', function(){\n      describe('defaults', function(){\n        it('to a non-empty array', function(){\n          var db = start()\n            , DefaultArraySchema = new Schema({\n                  arr: {type: Array, cast: String, default: ['a', 'b', 'c']}\n                , single: {type: Array, cast: String, default: ['a']}\n              });\n          mongoose.model('DefaultArray', DefaultArraySchema);\n          var DefaultArray = db.model('DefaultArray', collection);\n          var arr = new DefaultArray;\n          db.close();\n          assert.equal(arr.get('arr').length, 3)\n          assert.equal(arr.get('arr')[0],'a');\n          assert.equal(arr.get('arr')[1],'b');\n          assert.equal(arr.get('arr')[2],'c');\n          assert.equal(arr.get('single').length, 1)\n          assert.equal(arr.get('single')[0],'a');\n        });\n\n        it('empty', function(){\n          var db = start()\n            , DefaultZeroCardArraySchema = new Schema({\n                arr: {type: Array, cast: String, default: []}\n              , auto: [Number]\n              });\n          mongoose.model('DefaultZeroCardArray', DefaultZeroCardArraySchema);\n          var DefaultZeroCardArray = db.model('DefaultZeroCardArray', collection);\n          db.close();\n          var arr = new DefaultZeroCardArray();\n          assert.equal(arr.get('arr').length, 0);\n          assert.equal(arr.arr.length, 0);\n          assert.equal(arr.auto.length, 0);\n        });\n      });\n    })\n\n    it('a hash with one null value', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost({\n        title: null\n      });\n      db.close();\n      assert.strictEqual(null, post.title);\n    });\n\n    it('when saved', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , pending = 2;\n\n      function cb () {\n        if (--pending) return;\n        db.close();\n        done();\n      }\n\n      var post = new BlogPost();\n      post.on('save', function (post) {\n        assert.ok(post.get('_id') instanceof DocumentObjectId);\n\n        assert.equal(undefined, post.get('title'));\n        assert.equal(undefined, post.get('slug'));\n        assert.equal(undefined, post.get('date'));\n        assert.equal(undefined, post.get('published'));\n\n        assert.equal(typeof post.get('meta'), 'object');\n        assert.deepEqual(post.get('meta'), {});\n        assert.equal(undefined, post.get('meta.date'));\n        assert.equal(undefined, post.get('meta.visitors'));\n\n        assert.ok(post.get('owners') instanceof MongooseArray);\n        assert.ok(post.get('comments') instanceof DocumentArray);\n        cb();\n      });\n\n      post.save(function(err, post){\n        assert.ifError(err);\n        assert.ok(post.get('_id') instanceof DocumentObjectId);\n\n        assert.equal(undefined, post.get('title'));\n        assert.equal(undefined, post.get('slug'));\n        assert.equal(undefined, post.get('date'));\n        assert.equal(undefined, post.get('published'));\n\n        assert.equal(typeof post.get('meta'), 'object');\n        assert.deepEqual(post.get('meta'),{});\n        assert.equal(undefined, post.get('meta.date'));\n        assert.equal(undefined, post.get('meta.visitors'));\n\n        assert.ok(post.get('owners') instanceof MongooseArray);\n        assert.ok(post.get('comments') instanceof DocumentArray);\n        cb();\n      });\n    })\n\n    describe('init', function(){\n      it('works', function(){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        var post = new BlogPost()\n        db.close();\n\n        post.init({\n            title       : 'Test'\n          , slug        : 'test'\n          , date        : new Date\n          , meta        : {\n                date      : new Date\n              , visitors  : 5\n            }\n          , published   : true\n          , owners      : [new DocumentObjectId, new DocumentObjectId]\n          , comments    : [\n                              { title: 'Test', date: new Date, body: 'Test' }\n                            , { title: 'Super', date: new Date, body: 'Cool' }\n                          ]\n        });\n\n        assert.equal(post.get('title'),'Test');\n        assert.equal(post.get('slug'),'test');\n        assert.ok(post.get('date') instanceof Date);\n        assert.equal('object', typeof post.get('meta'));\n        assert.ok(post.get('meta').date instanceof Date);\n        assert.equal(typeof post.get('meta').visitors, 'number')\n        assert.equal(post.get('published'), true);\n\n        assert.equal(post.title,'Test');\n        assert.equal(post.slug,'test');\n        assert.ok(post.date instanceof Date);\n        assert.equal(typeof post.meta,'object');\n        assert.ok(post.meta.date instanceof Date);\n        assert.equal(typeof post.meta.visitors,'number');\n        assert.equal(post.published, true);\n\n        assert.ok(post.get('owners') instanceof MongooseArray);\n        assert.ok(post.get('owners')[0] instanceof DocumentObjectId);\n        assert.ok(post.get('owners')[1] instanceof DocumentObjectId);\n\n        assert.ok(post.owners instanceof MongooseArray);\n        assert.ok(post.owners[0] instanceof DocumentObjectId);\n        assert.ok(post.owners[1] instanceof DocumentObjectId);\n\n        assert.ok(post.get('comments') instanceof DocumentArray);\n        assert.ok(post.get('comments')[0] instanceof EmbeddedDocument);\n        assert.ok(post.get('comments')[1] instanceof EmbeddedDocument);\n\n        assert.ok(post.comments instanceof DocumentArray);\n        assert.ok(post.comments[0] instanceof EmbeddedDocument);\n        assert.ok(post.comments[1] instanceof EmbeddedDocument);\n      })\n\n      it('partially', function(){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        db.close();\n        var post = new BlogPost;\n        post.init({\n            title       : 'Test'\n          , slug        : 'test'\n          , date        : new Date\n        });\n\n        assert.equal(post.get('title'),'Test');\n        assert.equal(post.get('slug'),'test');\n        assert.ok(post.get('date') instanceof Date);\n        assert.equal('object', typeof post.get('meta'));\n\n        assert.deepEqual(post.get('meta'),{});\n        assert.equal(undefined, post.get('meta.date'));\n        assert.equal(undefined, post.get('meta.visitors'));\n        assert.equal(undefined, post.get('published'));\n\n        assert.ok(post.get('owners') instanceof MongooseArray);\n        assert.ok(post.get('comments') instanceof DocumentArray);\n      })\n\n      it('with partial hash', function(){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        db.close();\n        var post = new BlogPost({\n          meta: {\n              date      : new Date\n            , visitors  : 5\n          }\n        });\n\n        assert.equal(5, post.get('meta.visitors').valueOf());\n      });\n\n      it('isNew on embedded documents', function(){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        db.close();\n        var post = new BlogPost()\n        post.init({\n            title       : 'Test'\n          , slug        : 'test'\n          , comments    : [ { title: 'Test', date: new Date, body: 'Test' } ]\n        });\n\n        assert.equal(false, post.get('comments')[0].isNew);\n      })\n\n      it('isNew on embedded documents after saving', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        var post = new BlogPost({ title: 'hocus pocus' })\n        post.comments.push({ title: 'Humpty Dumpty', comments: [{title: 'nested'}] });\n        assert.equal(true, post.get('comments')[0].isNew);\n        assert.equal(true, post.get('comments')[0].comments[0].isNew);\n        post.invalidate('title'); // force error\n        post.save(function (err) {\n          assert.equal(true, post.isNew);\n          assert.equal(true, post.get('comments')[0].isNew);\n          assert.equal(true, post.get('comments')[0].comments[0].isNew);\n          post.save(function (err) {\n            db.close();\n            assert.strictEqual(null, err);\n            assert.equal(false, post.isNew);\n            assert.equal(false, post.get('comments')[0].isNew);\n            assert.equal(false, post.get('comments')[0].comments[0].isNew);\n            done()\n          });\n        });\n      })\n    });\n  });\n\n  it('collection name can be specified through schema', function(){\n    var schema = new Schema({ name: String }, { collection: 'users1' });\n    var Named = mongoose.model('CollectionNamedInSchema1', schema);\n    assert.equal(Named.prototype.collection.name,'users1');\n\n    var db = start();\n    var users2schema = new Schema({ name: String }, { collection: 'users2' });\n    var Named2 = db.model('CollectionNamedInSchema2', users2schema);\n    db.close();\n    assert.equal(Named2.prototype.collection.name,'users2');\n  });\n\n  it('saving a model with a null value should perpetuate that null value to the db', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost({\n      title: null\n    });\n    assert.strictEqual(null, post.title);\n    post.save( function (err) {\n      assert.strictEqual(err, null);\n      BlogPost.findById(post.id, function (err, found) {\n        db.close();\n        assert.strictEqual(err, null);\n        assert.strictEqual(found.title, null);\n        done();\n      });\n    });\n  });\n\n  it('instantiating a model with a hash that maps to at least 1 undefined value', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost({\n      title: undefined\n    });\n    assert.strictEqual(undefined, post.title);\n    post.save( function (err) {\n      assert.strictEqual(null, err);\n      BlogPost.findById(post.id, function (err, found) {\n        db.close();\n        assert.strictEqual(err, null);\n        assert.strictEqual(found.title, undefined);\n        done();\n      });\n    });\n  })\n\n  it('modified nested objects which contain MongoseNumbers should not cause a RangeError on save (gh-714)', function(done){\n    var db =start()\n\n    var schema = new Schema({\n        nested: {\n            num: Number\n        }\n    });\n\n    var M = db.model('NestedObjectWithMongooseNumber', schema);\n    var m = new M;\n    m.nested = null;\n    m.save(function (err) {\n      assert.ifError(err);\n\n      M.findById(m, function (err, m) {\n        assert.ifError(err);\n        m.nested.num = 5;\n        m.save(function (err) {\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    });\n  })\n\n  it('no RangeError on remove() of a doc with Number _id (gh-714)', function(done){\n    var db = start()\n\n    var MySchema = new Schema({\n        _id: { type: Number },\n        name: String\n    });\n\n    var MyModel = db.model('MyModel', MySchema, 'numberrangeerror'+random());\n\n    var instance = new MyModel({\n        name: 'test'\n      , _id: 35\n    });\n\n    instance.save(function (err) {\n      assert.ifError(err);\n\n      MyModel.findById(35, function (err, doc) {\n        assert.ifError(err);\n\n        doc.remove(function (err) {\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    });\n  });\n\n  it('over-writing a number should persist to the db (gh-342)', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost({\n      meta: {\n          date      : new Date\n        , visitors  : 10\n      }\n    });\n\n    post.save( function (err) {\n      assert.ifError(err);\n      post.set('meta.visitors', 20);\n      post.save( function (err) {\n        assert.ifError(err);\n        BlogPost.findById(post.id, function (err, found) {\n          assert.ifError(err);\n          assert.equal(20, found.get('meta.visitors').valueOf());\n          db.close();\n          done();\n        });\n      });\n    });\n  });\n\n  describe('methods', function(){\n    it('can be defined', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      db.close();\n      var post = new BlogPost();\n      assert.equal(post, post.cool());\n    })\n\n    it('can be defined on embedded documents', function(){\n      var db = start();\n      var ChildSchema = new Schema({ name: String });\n      ChildSchema.method('talk', function () {\n        return 'gaga';\n      });\n\n      var ParentSchema = new Schema({\n        children: [ChildSchema]\n      });\n\n      var ChildA = db.model('ChildA', ChildSchema, 'children_' + random());\n      var ParentA = db.model('ParentA', ParentSchema, 'parents_' + random());\n      db.close();\n\n      var c = new ChildA;\n      assert.equal('function', typeof c.talk);\n\n      var p = new ParentA();\n      p.children.push({});\n      assert.equal('function', typeof p.children[0].talk);\n    })\n  })\n\n  describe('statics', function(){\n    it('can be defined', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      db.close();\n      assert.equal(BlogPost, BlogPost.woot());\n    });\n  });\n\n  describe('casting', function(){\n    it('error', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , threw = false;\n\n      var post = new BlogPost;\n\n      try {\n        post.init({\n            date: 'Test'\n        });\n      } catch(e){\n        threw = true;\n      }\n\n      assert.equal(false, threw);\n\n      try {\n        post.set('title', 'Test');\n      } catch(e){\n        threw = true;\n      }\n\n      assert.equal(false, threw);\n\n      post.save(function(err){\n        db.close();\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof CastError);\n        done();\n      });\n    })\n    it('nested error', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , threw = false;\n\n      var post = new BlogPost;\n\n      try {\n        post.init({\n            meta: {\n                date: 'Test'\n            }\n        });\n      } catch(e){\n        threw = true;\n      }\n\n      assert.equal(false, threw);\n\n      try {\n        post.set('meta.date', 'Test');\n      } catch(e){\n        threw = true;\n      }\n\n      assert.equal(false, threw);\n\n      post.save(function(err){\n        db.close();\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof CastError);\n        done();\n      });\n    });\n    it('subdocument error', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , threw = false;\n\n      var post = new BlogPost()\n      post.init({\n          title       : 'Test'\n        , slug        : 'test'\n        , comments    : [ { title: 'Test', date: new Date, body: 'Test' } ]\n      });\n\n      post.get('comments')[0].set('date', 'invalid');\n\n      post.save(function(err){\n        db.close();\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof CastError);\n        done();\n      });\n    });\n    it('subdocument error when adding a subdoc', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , threw = false;\n\n      var post = new BlogPost()\n\n      try {\n        post.get('comments').push({\n            date: 'Bad date'\n        });\n      } catch (e) {\n        threw = true;\n      }\n\n      assert.equal(false, threw);\n\n      post.save(function(err){\n        db.close();\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof CastError);\n        done();\n      });\n    });\n\n    it('updates', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost();\n      post.set('title', '1');\n\n      var id = post.get('_id');\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPost.update({ title: 1, _id: id }, { title: 2 }, function (err) {\n          assert.ifError(err);\n\n          BlogPost.findOne({ _id: post.get('_id') }, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(doc.get('title'), '2');\n            done();\n          });\n        });\n      });\n    });\n\n    it('$pull', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , post = new BlogPost();\n\n      db.close();\n      post.get('numbers').push('3');\n      assert.equal(post.get('numbers')[0], 3);\n    });\n\n    it('$push', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , post = new BlogPost();\n\n      post.get('numbers').push(1, 2, 3, 4);\n      post.save( function (err) {\n        BlogPost.findById( post.get('_id'), function (err, found) {\n          assert.equal(found.get('numbers').length,4);\n          found.get('numbers').pull('3');\n          found.save( function (err) {\n            BlogPost.findById(found.get('_id'), function (err, found2) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(found2.get('numbers').length,3);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('Number arrays', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost();\n      post.numbers.push(1, '2', 3);\n\n      post.save(function (err) {\n        assert.strictEqual(err, null);\n\n        BlogPost.findById(post._id, function (err, doc) {\n          assert.ifError(err);\n\n          assert.ok(~doc.numbers.indexOf(1));\n          assert.ok(~doc.numbers.indexOf(2));\n          assert.ok(~doc.numbers.indexOf(3));\n\n          db.close();\n          done();\n        });\n      })\n    });\n\n    it('date casting compat with datejs (gh-502)', function(done){\n      var db = start()\n\n      Date.prototype.toObject = function() {\n          return {\n                millisecond: 86\n              , second: 42\n              , minute: 47\n              , hour: 17\n              , day: 13\n              , week: 50\n              , month: 11\n              , year: 2011\n          };\n      };\n\n      var S = new Schema({\n          name: String\n        , description: String\n        , sabreId: String\n        , data: {\n              lastPrice: Number\n            , comm: String\n            , curr: String\n            , rateName: String\n          }\n        , created: { type: Date, default: Date.now }\n        , valid: { type: Boolean, default: true }\n      });\n\n      var M = db.model('gh502', S);\n\n      var m = new M;\n      m.save(function (err) {\n        assert.ifError(err);\n        M.findById(m._id, function (err, m) {\n          assert.ifError(err);\n          m.save(function (err) {\n            assert.ifError(err);\n            M.remove(function (err) {\n              db.close();\n              delete Date.prototype.toObject;\n              assert.ifError(err);\n              done();\n            });\n          });\n        });\n      });\n    });\n  });\n\n  describe('validation', function(){\n    it('works', function(done){\n      function dovalidate (val) {\n        assert.equal('correct', this.asyncScope);\n        return true;\n      }\n\n      function dovalidateAsync (val, callback) {\n        assert.equal('correct', this.scope);\n        process.nextTick(function () {\n          callback(true);\n        });\n      }\n\n      mongoose.model('TestValidation', new Schema({\n          simple: { type: String, required: true }\n        , scope: { type: String, validate: [dovalidate, 'scope failed'], required: true }\n        , asyncScope: { type: String, validate: [dovalidateAsync, 'async scope failed'], required: true }\n      }));\n\n      var db = start()\n        , TestValidation = db.model('TestValidation');\n\n      var post = new TestValidation();\n      post.set('simple', '');\n      post.set('scope', 'correct');\n      post.set('asyncScope', 'correct');\n\n      post.save(function(err){\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n\n        post.set('simple', 'here');\n        post.save(function(err){\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    });\n\n    it('custom messaging', function(done){\n      function validate (val) {\n        return val === 'abc';\n      }\n      mongoose.model('TestValidationMessage', new Schema({\n          simple: { type: String, validate: [validate, 'must be abc'] }\n      }));\n\n      var db = start()\n        , TestValidationMessage = db.model('TestValidationMessage');\n\n      var post = new TestValidationMessage();\n      post.set('simple', '');\n\n      post.save(function(err){\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n        assert.ok(err.errors.simple instanceof ValidatorError);\n        assert.equal(err.errors.simple.message,'Validator \"must be abc\" failed for path simple');\n        assert.equal(post.errors.simple.message,'Validator \"must be abc\" failed for path simple');\n\n        post.set('simple', 'abc');\n        post.save(function(err){\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    })\n\n    it('with Model.schema.path introspection (gh-272)', function(done){\n      var db = start();\n      var IntrospectionValidationSchema = new Schema({\n        name: String\n      });\n      var IntrospectionValidation = db.model('IntrospectionValidation', IntrospectionValidationSchema, 'introspections_' + random());\n      IntrospectionValidation.schema.path('name').validate(function (value) {\n        return value.length < 2;\n      }, 'Name cannot be greater than 1 character');\n      var doc = new IntrospectionValidation({name: 'hi'});\n      doc.save( function (err) {\n        db.close();\n        assert.equal(err.errors.name.message,\"Validator \\\"Name cannot be greater than 1 character\\\" failed for path name\");\n        assert.equal(err.name,\"ValidationError\");\n        assert.equal(err.message,\"Validation failed\");\n        done();\n      });\n    });\n\n    it('of required undefined values', function(done){\n      mongoose.model('TestUndefinedValidation', new Schema({\n          simple: { type: String, required: true }\n      }));\n\n      var db = start()\n        , TestUndefinedValidation = db.model('TestUndefinedValidation');\n\n      var post = new TestUndefinedValidation;\n\n      post.save(function(err){\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n\n        post.set('simple', 'here');\n        post.save(function(err){\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    })\n\n    it('save callback should only execute once (gh-319)', function(done){\n      var db = start()\n\n      var D = db.model('CallbackFiresOnceValidation', new Schema({\n          username: { type: String, validate: /^[a-z]{6}$/i }\n        , email: { type: String, validate: /^[a-z]{6}$/i }\n        , password: { type: String, validate: /^[a-z]{6}$/i }\n      }));\n\n      var post = new D({\n          username: \"nope\"\n        , email: \"too\"\n        , password: \"short\"\n      });\n\n      var timesCalled = 0;\n\n      post.save(function (err) {\n        db.close();\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n\n        assert.equal(1, ++timesCalled);\n\n        assert.equal(Object.keys(err.errors).length, 3);\n        assert.ok(err.errors.password instanceof ValidatorError);\n        assert.ok(err.errors.email instanceof ValidatorError);\n        assert.ok(err.errors.username instanceof ValidatorError);\n        assert.equal(err.errors.password.message,'Validator failed for path password');\n        assert.equal(err.errors.email.message,'Validator failed for path email');\n        assert.equal(err.errors.username.message,'Validator failed for path username');\n\n        assert.equal(Object.keys(post.errors).length, 3);\n        assert.ok(post.errors.password instanceof ValidatorError);\n        assert.ok(post.errors.email instanceof ValidatorError);\n        assert.ok(post.errors.username instanceof ValidatorError);\n        assert.equal(post.errors.password.message,'Validator failed for path password');\n        assert.equal(post.errors.email.message,'Validator failed for path email');\n        assert.equal(post.errors.username.message,'Validator failed for path username');\n        done();\n      });\n    });\n\n    it('query result', function(done){\n      mongoose.model('TestValidationOnResult', new Schema({\n          resultv: { type: String, required: true }\n      }));\n\n      var db = start()\n        , TestV = db.model('TestValidationOnResult');\n\n      var post = new TestV;\n\n      post.validate(function (err) {\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n\n        post.resultv = 'yeah';\n        post.save(function (err) {\n          assert.ifError(err);\n          TestV.findOne({ _id: post.id }, function (err, found) {\n            assert.ifError(err);\n            assert.equal(found.resultv,'yeah');\n            found.save(function(err){\n              db.close();\n              assert.ifError(err);\n              done();\n            })\n          });\n        });\n      });\n    });\n\n    it('of required previously existing null values', function(done){\n      mongoose.model('TestPreviousNullValidation', new Schema({\n          previous: { type: String, required: true }\n        , a: String\n      }));\n\n      var db = start()\n        , TestP = db.model('TestPreviousNullValidation')\n\n      TestP.collection.insert({ a: null, previous: null}, {}, function (err, f) {\n        assert.ifError(err);\n\n        TestP.findOne({_id: f[0]._id}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(false, found.isNew);\n          assert.strictEqual(found.get('previous'), null);\n\n          found.validate(function(err){\n            assert.ok(err instanceof MongooseError);\n            assert.ok(err instanceof ValidationError);\n\n            found.set('previous', 'yoyo');\n            found.save(function (err) {\n              assert.strictEqual(err, null);\n              db.close();\n              done()\n            });\n          })\n        })\n      });\n    })\n\n    it('nested', function(done){\n      mongoose.model('TestNestedValidation', new Schema({\n          nested: {\n              required: { type: String, required: true }\n          }\n      }));\n\n      var db = start()\n        , TestNestedValidation = db.model('TestNestedValidation');\n\n      var post = new TestNestedValidation();\n      post.set('nested.required', null);\n\n      post.save(function(err){\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n\n        post.set('nested.required', 'here');\n        post.save(function(err){\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    })\n\n    it('of nested subdocuments', function(done){\n      var Subsubdocs= new Schema({ required: { type: String, required: true }});\n\n      var Subdocs = new Schema({\n          required: { type: String, required: true }\n        , subs: [Subsubdocs]\n      });\n\n      mongoose.model('TestSubdocumentsValidation', new Schema({\n          items: [Subdocs]\n      }));\n\n      var db = start()\n        , TestSubdocumentsValidation = db.model('TestSubdocumentsValidation');\n\n      var post = new TestSubdocumentsValidation();\n\n      post.get('items').push({ required: '', subs: [{required: ''}] });\n\n      post.save(function(err){\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n        assert.ok(err.errors['items.0.subs.0.required'] instanceof ValidatorError);\n        assert.equal(err.errors['items.0.subs.0.required'].message,'Validator \"required\" failed for path required');\n        assert.ok(post.errors['items.0.subs.0.required'] instanceof ValidatorError);\n        assert.equal(post.errors['items.0.subs.0.required'].message,'Validator \"required\" failed for path required');\n\n        assert.ok(!err.errors['items.0.required']);\n        assert.ok(!err.errors['items.0.required']);\n        assert.ok(!post.errors['items.0.required']);\n        assert.ok(!post.errors['items.0.required']);\n\n        post.items[0].subs[0].set('required', true);\n        assert.equal(undefined, post._validationError);\n\n        post.save(function(err){\n          assert.ok(err);\n          assert.ok(err.errors);\n          assert.ok(err.errors['items.0.required'] instanceof ValidatorError);\n          assert.equal(err.errors['items.0.required'].message,'Validator \"required\" failed for path required');\n\n          assert.ok(!err.errors['items.0.subs.0.required']);\n          assert.ok(!err.errors['items.0.subs.0.required']);\n          assert.ok(!post.errors['items.0.subs.0.required']);\n          assert.ok(!post.errors['items.0.subs.0.required']);\n\n          post.get('items')[0].set('required', true);\n          post.save(function(err){\n            db.close();\n            assert.ok(!post.errors);\n            assert.ifError(err);\n            done();\n          });\n        });\n      });\n    });\n\n    describe('async', function(){\n      it('works', function(done){\n        var executed = false;\n\n        function validator(v, fn){\n          setTimeout(function () {\n            executed = true;\n            fn(v !== 'test');\n          }, 5);\n        };\n        mongoose.model('TestAsyncValidation', new Schema({\n            async: { type: String, validate: [validator, 'async validator'] }\n        }));\n\n        var db = start()\n          , TestAsyncValidation = db.model('TestAsyncValidation');\n\n        var post = new TestAsyncValidation();\n        post.set('async', 'test');\n\n        post.save(function(err){\n          assert.ok(err instanceof MongooseError);\n          assert.ok(err instanceof ValidationError);\n          assert.ok(err.errors.async instanceof ValidatorError);\n          assert.equal(err.errors.async.message,'Validator \"async validator\" failed for path async');\n          assert.equal(true, executed);\n          executed = false;\n\n          post.set('async', 'woot');\n          post.save(function(err){\n            db.close();\n            assert.equal(true, executed);\n            assert.strictEqual(err, null);\n            done();\n          });\n        });\n      })\n\n      it('nested', function(done){\n        var executed = false;\n\n        function validator(v, fn){\n          setTimeout(function () {\n            executed = true;\n            fn(v !== 'test');\n          }, 5);\n        };\n\n        mongoose.model('TestNestedAsyncValidation', new Schema({\n            nested: {\n                async: { type: String, validate: [validator, 'async validator'] }\n            }\n        }));\n\n        var db = start()\n          , TestNestedAsyncValidation = db.model('TestNestedAsyncValidation');\n\n        var post = new TestNestedAsyncValidation();\n        post.set('nested.async', 'test');\n\n        post.save(function(err){\n          assert.ok(err instanceof MongooseError);\n          assert.ok(err instanceof ValidationError);\n          assert.ok(executed);\n          executed = false;\n\n          post.validate(function(err){\n            assert.ok(err instanceof MongooseError);\n            assert.ok(err instanceof ValidationError);\n            assert.ok(executed);\n            executed = false;\n\n            post.set('nested.async', 'woot');\n            post.validate(function(err){\n              assert.ok(executed);\n              assert.equal(err, null);\n              executed = false;\n\n              post.save(function(err){\n                db.close();\n                assert.ok(executed);\n                assert.strictEqual(err, null);\n                done();\n              });\n            });\n          });\n        });\n      });\n\n      it('subdocuments', function(done){\n        var executed = false;\n\n        function validator (v, fn) {\n          setTimeout(function(){\n            executed = true;\n            fn(v !== '');\n          }, 5);\n        };\n\n        var Subdocs = new Schema({\n            required: { type: String, validate: [validator, 'async in subdocs'] }\n        });\n\n        mongoose.model('TestSubdocumentsAsyncValidation', new Schema({\n            items: [Subdocs]\n        }));\n\n        var db = start()\n          , Test = db.model('TestSubdocumentsAsyncValidation');\n\n        var post = new Test();\n\n        post.get('items').push({ required: '' });\n\n        post.save(function(err){\n          assert.ok(err instanceof MongooseError);\n          assert.ok(err instanceof ValidationError);\n          assert.ok(executed);\n          executed = false;\n\n          post.get('items')[0].set({ required: 'here' });\n          post.save(function(err){\n            db.close();\n            assert.ok(executed);\n            assert.strictEqual(err, null);\n            done();\n          });\n        });\n      });\n\n    });\n\n    it('without saving', function(done){\n      mongoose.model('TestCallingValidation', new Schema({\n        item: { type: String, required: true }\n      }));\n\n      var db = start()\n        , TestCallingValidation = db.model('TestCallingValidation');\n\n      var post = new TestCallingValidation;\n\n      assert.equal(true, post.schema.path('item').isRequired);\n      assert.strictEqual(post.isNew, true);\n\n      post.validate(function(err){\n        assert.ok(err instanceof MongooseError);\n        assert.ok(err instanceof ValidationError);\n        assert.strictEqual(post.isNew, true);\n\n        post.item = 'yo';\n        post.validate(function(err){\n          db.close();\n          assert.equal(err, null);\n          assert.strictEqual(post.isNew, true);\n          done();\n        });\n      });\n    });\n\n    it('when required is set to false', function(){\n      function validator () {\n        return true;\n      }\n\n      mongoose.model('TestRequiredFalse', new Schema({\n        result: { type: String, validate: [validator, 'chump validator'], required: false }\n      }));\n\n      var db = start()\n        , TestV = db.model('TestRequiredFalse');\n\n      var post = new TestV;\n\n      db.close();\n      assert.equal(false, post.schema.path('result').isRequired);\n    })\n\n    describe('middleware', function(){\n      it('works', function(done){\n        var db = start()\n          , ValidationMiddlewareSchema = null\n          , Post = null\n          , post = null;\n\n        ValidationMiddlewareSchema = new Schema({\n          baz: { type: String }\n        });\n\n        ValidationMiddlewareSchema.pre('validate', function(next) {\n          if (this.get('baz') == 'bad') {\n            this.invalidate('baz', 'bad');\n          }\n          next();\n        });\n\n        mongoose.model('ValidationMiddleware', ValidationMiddlewareSchema);\n\n        Post = db.model('ValidationMiddleware');\n        post = new Post();\n        post.set({baz: 'bad'});\n\n        post.save(function(err){\n          assert.ok(err instanceof MongooseError);\n          assert.ok(err instanceof ValidationError);\n          assert.equal(err.errors.baz.type,'bad');\n          assert.equal(err.errors.baz.path,'baz');\n\n          post.set('baz', 'good');\n          post.save(function(err){\n            db.close();\n            assert.strictEqual(err, null);\n            done();\n          });\n        });\n      })\n\n      it('async', function(done){\n        var db = start()\n          , AsyncValidationMiddlewareSchema = null\n          , Post = null\n          , post = null;\n\n        AsyncValidationMiddlewareSchema = new Schema({\n          prop: { type: String }\n        });\n\n        AsyncValidationMiddlewareSchema.pre('validate', true, function(next, done) {\n          var self = this;\n          setTimeout(function() {\n            if (self.get('prop') == 'bad') {\n              self.invalidate('prop', 'bad');\n            }\n            done();\n          }, 5);\n          next();\n        });\n\n        mongoose.model('AsyncValidationMiddleware', AsyncValidationMiddlewareSchema);\n\n        Post = db.model('AsyncValidationMiddleware');\n        post = new Post();\n        post.set({prop: 'bad'});\n\n        post.save(function(err){\n          assert.ok(err instanceof MongooseError);\n          assert.ok(err instanceof ValidationError);\n          assert.equal(err.errors.prop.type,'bad');\n          assert.equal(err.errors.prop.path,'prop');\n\n          post.set('prop', 'good');\n          post.save(function(err){\n            db.close();\n            assert.strictEqual(err, null);\n            done();\n          });\n        });\n      });\n\n      it('complex', function(done){\n        var db = start()\n          , ComplexValidationMiddlewareSchema = null\n          , Post = null\n          , post = null\n          , abc = function(v) {\n              return v === 'abc';\n            };\n\n        ComplexValidationMiddlewareSchema = new Schema({\n          baz: { type: String },\n          abc: { type: String, validate: [abc, 'must be abc'] },\n          test: { type: String, validate: [/test/, 'must also be abc'] },\n          required: { type: String, required: true }\n        });\n\n        ComplexValidationMiddlewareSchema.pre('validate', true, function(next, done) {\n          var self = this;\n          setTimeout(function() {\n            if (self.get('baz') == 'bad') {\n              self.invalidate('baz', 'bad');\n            }\n            done();\n          }, 5);\n          next();\n        });\n\n        mongoose.model('ComplexValidationMiddleware', ComplexValidationMiddlewareSchema);\n\n        Post = db.model('ComplexValidationMiddleware');\n        post = new Post();\n        post.set({\n          baz: 'bad',\n          abc: 'not abc',\n          test: 'fail'\n        });\n\n        post.save(function(err){\n          assert.ok(err instanceof MongooseError);\n          assert.ok(err instanceof ValidationError);\n          assert.equal(4, Object.keys(err.errors).length);\n          assert.ok(err.errors.baz instanceof ValidatorError);\n          assert.equal(err.errors.baz.type,'bad');\n          assert.equal(err.errors.baz.path,'baz');\n          assert.ok(err.errors.abc instanceof ValidatorError);\n          assert.equal(err.errors.abc.type,'must be abc');\n          assert.equal(err.errors.abc.path,'abc');\n          assert.ok(err.errors.test instanceof ValidatorError);\n          assert.equal(err.errors.test.type,'must also be abc');\n          assert.equal(err.errors.test.path,'test');\n          assert.ok(err.errors.required instanceof ValidatorError);\n          assert.equal(err.errors.required.type,'required');\n          assert.equal(err.errors.required.path,'required');\n\n          post.set({\n            baz: 'good',\n            abc: 'abc',\n            test: 'test',\n            required: 'here'\n          });\n\n          post.save(function(err){\n            db.close();\n            assert.strictEqual(err, null);\n            done();\n          });\n        });\n      })\n    })\n  });\n\n  describe('defaults application', function(){\n    it('works', function(){\n      var now = Date.now();\n\n      mongoose.model('TestDefaults', new Schema({\n          date: { type: Date, default: now }\n      }));\n\n      var db = start()\n        , TestDefaults = db.model('TestDefaults');\n\n      db.close();\n      var post = new TestDefaults;\n      assert.ok(post.get('date') instanceof Date);\n      assert.equal(+post.get('date'), now);\n    });\n\n    it('nested', function(){\n      var now = Date.now();\n\n      mongoose.model('TestNestedDefaults', new Schema({\n          nested: {\n              date: { type: Date, default: now }\n          }\n      }));\n\n      var db = start()\n        , TestDefaults = db.model('TestNestedDefaults');\n\n      var post = new TestDefaults();\n      db.close();\n      assert.ok(post.get('nested.date') instanceof Date);\n      assert.equal(+post.get('nested.date'), now);\n    })\n\n    it('subdocument', function(){\n      var now = Date.now();\n\n      var Items = new Schema({\n          date: { type: Date, default: now }\n      });\n\n      mongoose.model('TestSubdocumentsDefaults', new Schema({\n          items: [Items]\n      }));\n\n      var db = start()\n        , TestSubdocumentsDefaults = db.model('TestSubdocumentsDefaults');\n\n      db.close();\n      var post = new TestSubdocumentsDefaults();\n      post.get('items').push({});\n      assert.ok(post.get('items')[0].get('date') instanceof Date);\n      assert.equal(+post.get('items')[0].get('date'), now);\n    });\n\n    it('allows nulls', function(done){\n      var db = start();\n      var T = db.model('NullDefault', new Schema({ name: { type: String, default: null }}), collection);\n      var t = new T();\n\n      assert.strictEqual(null, t.name);\n\n      t.save(function (err) {\n        assert.ifError(err);\n\n        T.findById(t._id, function (err, t) {\n          db.close();\n          assert.ifError(err);\n          assert.strictEqual(null, t.name);\n          done();\n        });\n      });\n    });\n  });\n\n  describe('virtuals', function(){\n    it('getters', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , post = new BlogPost({\n              title: 'Letters from Earth'\n            , author: 'Mark Twain'\n          });\n\n      db.close();\n      assert.equal(post.get('titleWithAuthor'), 'Letters from Earth by Mark Twain');\n      assert.equal(post.titleWithAuthor,'Letters from Earth by Mark Twain');\n    });\n\n    it('set()', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , post = new BlogPost();\n\n      db.close();\n      post.set('titleWithAuthor', 'Huckleberry Finn by Mark Twain')\n      assert.equal(post.get('title'),'Huckleberry Finn');\n      assert.equal(post.get('author'),'Mark Twain');\n    });\n\n    it('should not be saved to the db', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , post = new BlogPost();\n\n      post.set('titleWithAuthor', 'Huckleberry Finn by Mark Twain');\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPost.findById(post.get('_id'), function (err, found) {\n          assert.ifError(err);\n\n          assert.equal(found.get('title'),'Huckleberry Finn');\n          assert.equal(found.get('author'),'Mark Twain');\n          assert.ok(! ('titleWithAuthor' in found.toObject()));\n          db.close();\n          done();\n        });\n      });\n    });\n\n    it('nested', function(){\n      var db = start()\n        , PersonSchema = new Schema({\n            name: {\n                first: String\n              , last: String\n            }\n          });\n\n      PersonSchema\n      .virtual('name.full')\n      .get(function () {\n        return this.get('name.first') + ' ' + this.get('name.last');\n      })\n      .set(function (fullName) {\n        var split = fullName.split(' ');\n        this.set('name.first', split[0]);\n        this.set('name.last', split[1]);\n      });\n\n      mongoose.model('Person', PersonSchema);\n\n      var Person = db.model('Person')\n        , person = new Person({\n            name: {\n                first: 'Michael'\n              , last: 'Sorrentino'\n            }\n          });\n\n      db.close();\n\n      assert.equal(person.get('name.full'),'Michael Sorrentino');\n      person.set('name.full', 'The Situation');\n      assert.equal(person.get('name.first'),'The');\n      assert.equal(person.get('name.last'),'Situation');\n\n      assert.equal(person.name.full,'The Situation');\n      person.name.full = 'Michael Sorrentino';\n      assert.equal(person.name.first,'Michael');\n      assert.equal(person.name.last,'Sorrentino');\n    });\n  });\n\n  describe('remove()', function(){\n    it('works', function(done){\n      var db = start()\n        , collection = 'blogposts_' + random()\n        , BlogPost = db.model('BlogPost', collection)\n        , post = new BlogPost();\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPost.find({}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(1, found.length);\n\n          BlogPost.remove({}, function (err) {\n            assert.ifError(err);\n\n            BlogPost.find({}, function (err, found2) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(0, found2.length);\n              done();\n            });\n          });\n        });\n      });\n    });\n  });\n\n  describe('getters', function(){\n    it('with same name on embedded docs do not class', function(){\n      var Post = new Schema({\n          title   : String\n        , author  : { name : String }\n        , subject : { name : String }\n      });\n\n      mongoose.model('PostWithClashGetters', Post);\n\n      var db = start()\n        , PostModel = db.model('PostWithClashGetters', 'postwithclash' + random());\n\n      var post = new PostModel({\n          title: 'Test'\n        , author: { name: 'A' }\n        , subject: { name: 'B' }\n      });\n\n      db.close();\n      assert.equal(post.author.name,'A');\n      assert.equal(post.subject.name,'B');\n      assert.equal(post.author.name,'A');\n    });\n\n    it('should not be triggered at construction (gh-685)', function(){\n      var db = start()\n        , called = false\n\n      db.close();\n\n      var schema = new mongoose.Schema({\n          number: {\n              type:Number\n            , set: function(x){return x/2}\n            , get: function(x){\n                called = true;\n                return x*2;\n              }\n          }\n      });\n\n      var A = mongoose.model('gettersShouldNotBeTriggeredAtConstruction', schema);\n\n      var a = new A({ number: 100 });\n      assert.equal(false, called);\n      var num = a.number;\n      assert.equal(true, called);\n      assert.equal(100, num.valueOf());\n      assert.equal(50, a.getValue('number').valueOf());\n\n      called = false;\n      var b = new A;\n      b.init({ number: 50 });\n      assert.equal(false, called);\n      num = b.number;\n      assert.equal(true, called);\n      assert.equal(100, num.valueOf());\n      assert.equal(50, b.getValue('number').valueOf());\n    })\n\n    it('with type defined with { type: Native } (gh-190)', function(){\n      var schema = new Schema({\n          date: { type: Date }\n      });\n\n      mongoose.model('ShortcutGetterObject', schema);\n\n      var db = start()\n        , ShortcutGetter = db.model('ShortcutGetterObject', 'shortcut' + random())\n        , post = new ShortcutGetter();\n\n      db.close();\n      post.set('date', Date.now());\n      assert.ok(post.date instanceof Date);\n    });\n\n    describe('nested', function(){\n      it('works', function(){\n        var schema = new Schema({\n          first: {\n            second: [Number]\n          }\n        });\n        mongoose.model('ShortcutGetterNested', schema);\n\n        var db = start()\n          , ShortcutGetterNested = db.model('ShortcutGetterNested', collection)\n          , doc = new ShortcutGetterNested();\n\n        db.close();\n        assert.equal('object', typeof doc.first);\n        assert.ok(doc.first.second instanceof MongooseArray);\n      });\n\n      it('works with object literals', function(){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        db.close();\n        var date = new Date;\n\n        var meta = {\n            date: date\n          , visitors: 5\n        };\n\n        var post = new BlogPost()\n        post.init({\n            meta: meta\n        });\n\n        assert.ok(post.get('meta').date instanceof Date);\n        assert.ok(post.meta.date instanceof Date);\n\n        var threw = false;\n        var getter1;\n        var getter2;\n        var strmet;\n        try {\n          strmet = JSON.stringify(meta);\n          getter1 = JSON.stringify(post.get('meta'));\n          getter2 = JSON.stringify(post.meta);\n        } catch (err) {\n          threw = true;\n        }\n\n        assert.equal(false, threw);\n        getter1 = JSON.parse(getter1);\n        getter2 = JSON.parse(getter2);\n        assert.equal(getter1.visitors, getter2.visitors);\n        assert.equal(getter1.date, getter2.date);\n\n        post.meta.date = new Date - 1000;\n        assert.ok(post.meta.date instanceof Date);\n        assert.ok(post.get('meta').date instanceof Date);\n\n        post.meta.visitors = 2;\n        assert.equal('number', typeof post.get('meta').visitors);\n        assert.equal('number', typeof post.meta.visitors);\n\n        var newmeta = {\n            date: date - 2000\n          , visitors: 234\n        };\n\n        post.set(newmeta, 'meta');\n\n        assert.ok(post.meta.date instanceof Date);\n        assert.ok(post.get('meta').date instanceof Date);\n        assert.equal('number', typeof post.meta.visitors);\n        assert.equal('number', typeof post.get('meta').visitors);\n        assert.equal((+post.meta.date),date - 2000);\n        assert.equal((+post.get('meta').date),date - 2000);\n        assert.equal((+post.meta.visitors),234);\n        assert.equal((+post.get('meta').visitors),234);\n\n        // set object directly\n        post.meta = {\n            date: date - 3000\n          , visitors: 4815162342\n        };\n\n        assert.ok(post.meta.date instanceof Date);\n        assert.ok(post.get('meta').date instanceof Date);\n        assert.equal('number', typeof post.meta.visitors);\n        assert.equal('number', typeof post.get('meta').visitors);\n        assert.equal((+post.meta.date),date - 3000);\n        assert.equal((+post.get('meta').date),date - 3000);\n        assert.equal((+post.meta.visitors),4815162342);\n        assert.equal((+post.get('meta').visitors),4815162342);\n      })\n\n      it('object property access works when root initd with null', function(done){\n        var db = start()\n\n        var schema = new Schema({\n          nest: {\n            st: String\n          }\n        });\n\n        mongoose.model('NestedStringA', schema);\n        var T = db.model('NestedStringA', collection);\n\n        var t = new T({ nest: null });\n\n        assert.strictEqual(t.nest.st, undefined);\n        t.nest = { st: \"jsconf rules\" };\n        assert.deepEqual(t.nest.toObject(),{ st: \"jsconf rules\" });\n        assert.equal(t.nest.st,\"jsconf rules\");\n\n        t.save(function (err) {\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n\n      it('object property access works when root initd with undefined', function(done){\n        var db = start()\n\n        var schema = new Schema({\n          nest: {\n            st: String\n          }\n        });\n\n        mongoose.model('NestedStringB', schema);\n        var T = db.model('NestedStringB', collection);\n\n        var t = new T({ nest: undefined });\n\n        assert.strictEqual(t.nest.st, undefined);\n        t.nest = { st: \"jsconf rules\" };\n        assert.deepEqual(t.nest.toObject(),{ st: \"jsconf rules\" });\n        assert.equal(t.nest.st,\"jsconf rules\");\n\n        t.save(function (err) {\n          db.close();\n          assert.ifError(err);\n          done();\n        })\n      });\n\n      it('pre-existing null object re-save', function(done){\n        var db = start()\n\n        var schema = new Schema({\n          nest: {\n              st: String\n            , yep: String\n          }\n        });\n\n        mongoose.model('NestedStringC', schema);\n        var T = db.model('NestedStringC', collection);\n\n        var t = new T({ nest: null });\n\n        t.save(function (err) {\n          assert.ifError(err);\n\n          t.nest = { st: \"jsconf rules\", yep: \"it does\" };\n\n          // check that entire `nest` object is being $set\n          var u = t._delta()[1];\n          assert.ok(u.$set);\n          assert.ok(u.$set.nest);\n          assert.equal(2, Object.keys(u.$set.nest).length);\n          assert.ok(u.$set.nest.yep);\n          assert.ok(u.$set.nest.st);\n\n          t.save(function (err) {\n            assert.ifError(err);\n\n            T.findById(t.id, function (err, t) {\n              assert.ifError(err);\n              assert.equal(t.nest.st,\"jsconf rules\");\n              assert.equal(t.nest.yep,\"it does\");\n\n              t.nest = null;\n              t.save(function (err) {\n                db.close();\n                assert.ifError(err);\n                assert.strictEqual(t._doc.nest, null);\n                done();\n              });\n            });\n          });\n        });\n      });\n\n      it('array of Mixed on existing doc can be pushed to', function(done){\n        var db = start();\n\n        mongoose.model('MySchema', new Schema({\n          nested: {\n            arrays: []\n          }\n        }));\n\n        var DooDad = db.model('MySchema')\n          , doodad = new DooDad({ nested: { arrays: [] } })\n          , date = 1234567890;\n\n        doodad.nested.arrays.push([\"+10\", \"yup\", date]);\n\n        doodad.save(function (err) {\n          assert.ifError(err);\n\n          DooDad.findById(doodad._id, function (err, doodad) {\n            assert.ifError(err);\n\n            assert.deepEqual(doodad.nested.arrays.toObject(), [['+10','yup',date]]);\n\n            doodad.nested.arrays.push([\"another\", 1]);\n\n            doodad.save(function (err) {\n              assert.ifError(err);\n\n              DooDad.findById(doodad._id, function (err, doodad) {\n                db.close();\n                assert.ifError(err);\n                assert.deepEqual(doodad.nested.arrays.toObject(), [['+10','yup',date], [\"another\", 1]]);\n                done();\n              });\n            });\n          });\n        });\n      })\n\n      it('props can be set directly when property was named \"type\"', function(done){\n        var db = start();\n\n        function def () {\n          return [{ x: 1 }, { x: 2 }, { x:3 }]\n        }\n\n        mongoose.model('MySchema2', new Schema({\n          nested: {\n              type: { type: String, default: 'yep' }\n            , array: {\n                type: Array, default: def\n              }\n          }\n        }));\n\n        var DooDad = db.model('MySchema2', collection)\n          , doodad = new DooDad()\n\n        doodad.save(function (err) {\n          assert.ifError(err);\n\n          DooDad.findById(doodad._id, function (err, doodad) {\n            assert.ifError(err);\n\n            assert.equal(doodad.nested.type,\"yep\");\n            assert.deepEqual(doodad.nested.array.toObject(), [{x:1},{x:2},{x:3}]);\n\n            doodad.nested.type = \"nope\";\n            doodad.nested.array = [\"some\", \"new\", \"stuff\"];\n\n            doodad.save(function (err) {\n              assert.ifError(err);\n\n              DooDad.findById(doodad._id, function (err, doodad) {\n                db.close();\n                assert.ifError(err);\n                assert.equal(doodad.nested.type,\"nope\");\n                assert.deepEqual(doodad.nested.array.toObject(), [\"some\", \"new\", \"stuff\"]);\n                done();\n              });\n            });\n          })\n        });\n      });\n\n    });\n  });\n\n  describe('setters', function(){\n    it('are used on embedded docs (gh-365 gh-390 gh-422)', function(done){\n      var db = start();\n\n      function setLat (val) {\n        return parseInt(val);\n      }\n\n      var tick = 0;\n      function uptick () {\n        return ++tick;\n      }\n\n      var Location = new Schema({\n          lat:  { type: Number, default: 0, set: setLat}\n        , long: { type: Number, set: uptick }\n      });\n\n      var Deal = new Schema({\n          title: String\n        , locations: [Location]\n      });\n\n      Location = db.model('Location', Location, 'locations_' + random());\n      Deal = db.model('Deal', Deal, 'deals_' + random());\n\n      var location = new Location({lat: 1.2, long: 10});\n      assert.equal(location.lat.valueOf(),1);\n      assert.equal(location.long.valueOf(),1);\n\n      var deal = new Deal({title: \"My deal\", locations: [{lat: 1.2, long: 33}]});\n      assert.equal(deal.locations[0].lat.valueOf(),1);\n      assert.equal(deal.locations[0].long.valueOf(),2);\n\n      deal.save(function (err) {\n        assert.ifError(err);\n        Deal.findById(deal._id, function (err, deal) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(deal.locations[0].lat.valueOf(),1);\n          // GH-422\n          assert.equal(deal.locations[0].long.valueOf(),2);\n          done();\n        });\n      });\n    });\n  });\n\n  it('changing a number non-atomically (gh-203)', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost();\n\n    post.meta.visitors = 5;\n\n    post.save(function (err) {\n      assert.ifError(err);\n\n      BlogPost.findById(post._id, function (err, doc) {\n        assert.ifError(err);\n\n        doc.meta.visitors -= 2;\n\n        doc.save(function (err) {\n          assert.ifError(err);\n\n          BlogPost.findById(post._id, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(3, +doc.meta.visitors);\n            done();\n          });\n        });\n      });\n    });\n  })\n\n  describe('atomic subdocument', function(){\n    it('saving', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , totalDocs = 4\n        , saveQueue = [];\n\n      var post = new BlogPost;\n\n      post.save(function(err){\n        assert.ifError(err);\n\n        BlogPost.findOne({ _id: post.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('comments').push({ title: '1' });\n          save(doc);\n        });\n\n        BlogPost.findOne({ _id: post.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('comments').push({ title: '2' });\n          save(doc);\n        });\n\n        BlogPost.findOne({ _id: post.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('comments').push({ title: '3' });\n          save(doc);\n        });\n\n        BlogPost.findOne({ _id: post.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('comments').push({ title: '4' }, { title: '5' });\n          save(doc);\n        });\n\n        function save(doc) {\n          saveQueue.push(doc);\n          if (saveQueue.length == 4) {\n            saveQueue.forEach(function (doc) {\n              doc.save(function (err) {\n                assert.ifError(err);\n                --totalDocs || complete();\n              });\n            });\n          }\n        };\n\n        function complete () {\n          BlogPost.findOne({ _id: post.get('_id') }, function (err, doc) {\n            db.close();\n\n            assert.ifError(err);\n            assert.equal(doc.get('comments').length,5);\n\n            var v = doc.get('comments').some(function(comment){\n              return comment.get('title') == '1';\n            });\n\n            assert.ok(v);\n\n            v = doc.get('comments').some(function(comment){\n              return comment.get('title') == '2';\n            });\n\n            assert.ok(v);\n\n            v = doc.get('comments').some(function(comment){\n              return comment.get('title') == '3';\n            })\n\n            assert.ok(v);\n\n            v = doc.get('comments').some(function(comment){\n              return comment.get('title') == '4';\n            });\n\n            assert.ok(v);\n\n            v = doc.get('comments').some(function(comment){\n              return comment.get('title') == '5';\n            });\n\n            assert.ok(v);\n            done();\n          });\n        };\n      });\n    })\n\n    it('setting (gh-310)', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n\n      BlogPost.create({\n        comments: [{ title: 'first-title', body: 'first-body'}]\n      }, function (err, blog) {\n        assert.ifError(err);\n        BlogPost.findById(blog.id, function (err, agent1blog) {\n          assert.ifError(err);\n          BlogPost.findById(blog.id, function (err, agent2blog) {\n            assert.ifError(err);\n            agent1blog.get('comments')[0].title = 'second-title';\n            agent1blog.save( function (err) {\n              assert.ifError(err);\n              agent2blog.get('comments')[0].body = 'second-body';\n              agent2blog.save( function (err) {\n                assert.ifError(err);\n                BlogPost.findById(blog.id, function (err, foundBlog) {\n                  assert.ifError(err);\n                  db.close();\n                  var comment = foundBlog.get('comments')[0];\n                  assert.equal(comment.title,'second-title');\n                  assert.equal(comment.body,'second-body');\n                  done();\n                });\n              });\n            });\n          });\n        });\n      });\n    })\n  });\n\n  it('doubly nested array saving and loading', function(done){\n    var Inner = new Schema({\n        arr: [Number]\n    });\n\n    var Outer = new Schema({\n        inner: [Inner]\n    });\n    mongoose.model('Outer', Outer);\n\n    var db = start();\n    var Outer = db.model('Outer', 'arr_test_' + random());\n\n    var outer = new Outer();\n    outer.inner.push({});\n    outer.save(function(err) {\n      assert.ifError(err);\n      assert.ok(outer.get('_id') instanceof DocumentObjectId);\n\n      Outer.findById(outer.get('_id'), function(err, found) {\n        assert.ifError(err);\n        assert.equal(1, found.inner.length);\n        found.inner[0].arr.push(5);\n        found.save(function(err) {\n          assert.ifError(err);\n          assert.ok(found.get('_id') instanceof DocumentObjectId);\n          Outer.findById(found.get('_id'), function(err, found2) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(1, found2.inner.length);\n            assert.equal(1, found2.inner[0].arr.length);\n            assert.equal(5, found2.inner[0].arr[0]);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('updating multiple Number $pushes as a single $pushAll', function(done){\n    var db = start()\n      , schema = new Schema({\n          nested: {\n            nums: [Number]\n          }\n        });\n\n    mongoose.model('NestedPushes', schema);\n    var Temp = db.model('NestedPushes', collection);\n\n    Temp.create({}, function (err, t) {\n      assert.ifError(err);\n      t.nested.nums.push(1);\n      t.nested.nums.push(2);\n\n      assert.equal(t.nested.nums.length,2);\n\n      t.save(function (err) {\n        assert.ifError(err);\n        assert.equal(t.nested.nums.length,2);\n        Temp.findById(t._id, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(t.nested.nums.length,2);\n          done();\n        });\n      });\n    });\n  })\n\n  it('updating at least a single $push and $pushAll as a single $pushAll', function(done){\n    var db = start()\n      , schema = new Schema({\n          nested: {\n            nums: [Number]\n          }\n        });\n\n    mongoose.model('NestedPushes', schema);\n    var Temp = db.model('NestedPushes', collection);\n\n    Temp.create({}, function (err, t) {\n      assert.ifError(err);\n      t.nested.nums.push(1);\n      t.nested.nums.push(2, 3);\n      assert.equal(3, t.nested.nums.length);\n\n      t.save(function (err) {\n        assert.ifError(err);\n        assert.equal(t.nested.nums.length, 3);\n        Temp.findById(t._id, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(found.nested.nums.length, 3);\n          done();\n        });\n      });\n    });\n  });\n\n  it('activePaths should be updated for nested modifieds', function(done){\n    var db = start()\n      , schema = new Schema({\n          nested: {\n            nums: [Number]\n          }\n        });\n\n    mongoose.model('NestedPushes', schema);\n    var Temp = db.model('NestedPushes', collection);\n\n    Temp.create({nested: {nums: [1, 2, 3, 4, 5]}}, function (err, t) {\n      assert.ifError(err);\n      t.nested.nums.pull(1);\n      t.nested.nums.pull(2);\n      assert.equal(t._activePaths.paths['nested.nums'],'modify');\n      db.close();\n      done();\n    });\n  })\n\n  it('$pull should affect what you see in an array before a save', function(done){\n    var db = start()\n      , schema = new Schema({\n          nested: {\n            nums: [Number]\n          }\n        });\n\n    mongoose.model('NestedPushes', schema);\n    var Temp = db.model('NestedPushes', collection);\n\n    Temp.create({nested: {nums: [1, 2, 3, 4, 5]}}, function (err, t) {\n      assert.ifError(err);\n      t.nested.nums.pull(1);\n      assert.equal(4, t.nested.nums.length);\n      db.close();\n      done();\n    });\n  });\n\n  it('$shift', function(done){\n    var db = start()\n      , schema = new Schema({\n          nested: {\n            nums: [Number]\n          }\n        });\n\n    mongoose.model('TestingShift', schema);\n    var Temp = db.model('TestingShift', collection);\n\n    Temp.create({ nested: { nums: [1,2,3] }}, function (err, t) {\n      assert.ifError(err);\n\n      Temp.findById(t._id, function (err, found) {\n        assert.ifError(err);\n        assert.equal(found.nested.nums.length, 3);\n        found.nested.nums.$pop();\n        assert.equal(found.nested.nums.length, 2);\n        assert.equal(found.nested.nums[0],1);\n        assert.equal(found.nested.nums[1],2);\n\n        found.save(function (err) {\n          assert.ifError(err);\n          Temp.findById(t._id, function (err, found) {\n            assert.ifError(err);\n            assert.equal(2, found.nested.nums.length);\n            assert.equal(1, found.nested.nums[0],1);\n            assert.equal(2, found.nested.nums[1],2);\n            found.nested.nums.$shift();\n            assert.equal(1, found.nested.nums.length);\n            assert.equal(found.nested.nums[0],2);\n\n            found.save(function (err) {\n              assert.ifError(err);\n              Temp.findById(t._id, function (err, found) {\n                db.close();\n                assert.ifError(err);\n                assert.equal(found.nested.nums.length,1);\n                assert.equal(found.nested.nums[0],2);\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  })\n\n  describe('saving embedded arrays', function(){\n    it('of Numbers atomically', function(done){\n      var db = start()\n        , TempSchema = new Schema({\n            nums: [Number]\n          })\n        , totalDocs = 2\n        , saveQueue = [];\n\n      mongoose.model('Temp', TempSchema);\n      var Temp = db.model('Temp', collection);\n\n      var t = new Temp();\n\n      t.save(function(err){\n        assert.ifError(err);\n\n        Temp.findOne({ _id: t.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('nums').push(1);\n          save(doc);\n        });\n\n        Temp.findOne({ _id: t.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('nums').push(2, 3);\n          save(doc);\n        });\n\n        function save(doc) {\n          saveQueue.push(doc);\n          if (saveQueue.length == totalDocs) {\n            saveQueue.forEach(function (doc) {\n              doc.save(function (err) {\n                assert.ifError(err);\n                --totalDocs || complete();\n              });\n            });\n          }\n        };\n\n        function complete () {\n          Temp.findOne({ _id: t.get('_id') }, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(3, doc.get('nums').length);\n\n            var v = doc.get('nums').some(function(num){\n              return num.valueOf() == '1';\n            });\n            assert.ok(v);\n\n            v = doc.get('nums').some(function(num){\n              return num.valueOf() == '2';\n            });\n            assert.ok(v);\n\n            v = doc.get('nums').some(function(num){\n              return num.valueOf() == '3';\n            });\n            assert.ok(v);\n            done()\n          });\n        };\n      });\n    })\n\n    it('of Strings atomically', function(done){\n      var db = start()\n        , StrListSchema = new Schema({\n            strings: [String]\n          })\n        , totalDocs = 2\n        , saveQueue = [];\n\n      mongoose.model('StrList', StrListSchema);\n      var StrList = db.model('StrList');\n\n      var t = new StrList();\n\n      t.save(function(err){\n        assert.ifError(err);\n\n        StrList.findOne({ _id: t.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('strings').push('a');\n          save(doc);\n        });\n\n        StrList.findOne({ _id: t.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('strings').push('b', 'c');\n          save(doc);\n        });\n\n\n        function save(doc) {\n          saveQueue.push(doc);\n          if (saveQueue.length == totalDocs) {\n            saveQueue.forEach(function (doc) {\n              doc.save(function (err) {\n                assert.ifError(err);\n                --totalDocs || complete();\n              });\n            });\n          }\n        };\n\n        function complete () {\n          StrList.findOne({ _id: t.get('_id') }, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n\n            assert.equal(3, doc.get('strings').length);\n\n            var v = doc.get('strings').some(function(str){\n              return str == 'a';\n            });\n            assert.ok(v);\n\n            v = doc.get('strings').some(function(str){\n              return str == 'b';\n            });\n            assert.ok(v);\n\n            v = doc.get('strings').some(function(str){\n              return str == 'c';\n            });\n            assert.ok(v);\n            done();\n          });\n        };\n      });\n    })\n\n    it('of Buffers atomically', function(done){\n      var db = start()\n        , BufListSchema = new Schema({\n            buffers: [Buffer]\n          })\n        , totalDocs = 2\n        , saveQueue = [];\n\n      mongoose.model('BufList', BufListSchema);\n      var BufList = db.model('BufList');\n\n      var t = new BufList();\n\n      t.save(function(err){\n        assert.ifError(err);\n\n        BufList.findOne({ _id: t.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('buffers').push(new Buffer([140]));\n          save(doc);\n        });\n\n        BufList.findOne({ _id: t.get('_id') }, function(err, doc){\n          assert.ifError(err);\n          doc.get('buffers').push(new Buffer([141]), new Buffer([142]));\n          save(doc);\n        });\n\n        function save(doc) {\n          saveQueue.push(doc);\n          if (saveQueue.length == totalDocs) {\n            saveQueue.forEach(function (doc) {\n              doc.save(function (err) {\n                assert.ifError(err);\n                --totalDocs || complete();\n              });\n            });\n          }\n        };\n\n        function complete () {\n          BufList.findOne({ _id: t.get('_id') }, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n\n            assert.equal(3, doc.get('buffers').length);\n\n            var v = doc.get('buffers').some(function(buf){\n              return buf[0] == 140;\n            });\n            assert.ok(v);\n\n            v  = doc.get('buffers').some(function(buf){\n              return buf[0] == 141;\n            });\n            assert.ok(v);\n\n            v = doc.get('buffers').some(function(buf){\n              return buf[0] == 142;\n            });\n            assert.ok(v);\n\n            done();\n          });\n        };\n      });\n    })\n\n    it('works with modified element properties + doc removal (gh-975)', function(done){\n      var db = start()\n        , B = db.model('BlogPost', collection)\n        , b = new B({ comments: [{ title: 'gh-975' }] });\n\n      b.save(function (err) {\n        assert.ifError(err);\n\n        b.comments[0].title = 'changed';\n        b.save(function (err) {\n          assert.ifError(err);\n\n          b.comments[0].remove();\n          b.save(function (err) {\n            assert.ifError(err);\n            db.close();\n            done();\n          })\n        });\n      })\n    })\n\n    it('updating an embedded document in an embedded array with set call', function(done) {\n      var db = start(),\n        BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create({\n        comments: [{\n          title: 'before-change'\n        }]\n      }, function(err, post) {\n        assert.ifError(err);\n        BlogPost.findById(post._id, function(err, found) {\n          assert.ifError(err);\n          assert.equal('before-change', found.comments[0].title);\n          var subDoc = [{\n            _id: found.comments[0]._id,\n            title: 'after-change'\n          }];\n          found.set('comments', subDoc);\n\n          found.save(function(err) {\n            assert.ifError(err);\n            BlogPost.findById(found._id, function(err, updated) {\n              db.close();\n              assert.ifError(err);\n              assert.equal('after-change', updated.comments[0].title);\n              done();\n            });\n          });\n        });\n      });\n    });\n  });\n\n  it('updating an embedded document in an embedded array (gh-255)', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    BlogPost.create({comments: [{title: 'woot'}]}, function (err, post) {\n      assert.ifError(err);\n      BlogPost.findById(post._id, function (err, found) {\n        assert.ifError(err);\n        assert.equal('woot', found.comments[0].title);\n        found.comments[0].title = 'notwoot';\n        found.save( function (err) {\n          assert.ifError(err);\n          BlogPost.findById(found._id, function (err, updated) {\n            db.close();\n            assert.ifError(err);\n            assert.equal('notwoot', updated.comments[0].title);\n            done();\n          });\n        });\n      });\n    });\n  })\n\n  it('updating an embedded array document to an Object value (gh-334)', function(done){\n    var db = start()\n      , SubSchema = new Schema({ \n          name : String , \n          subObj : { subName : String } \n        });\n    var GH334Schema = new Schema ({ name : String , arrData : [ SubSchema] });\n\n    mongoose.model('GH334' , GH334Schema);\n    var AModel = db.model('GH334');\n    var instance = new AModel();\n\n    instance.set( { name : 'name-value' , arrData : [ { name : 'arrName1' , subObj : { subName : 'subName1' } } ] });\n    instance.save(function(err) {\n      assert.ifError(err);\n      AModel.findById(instance.id, function(err, doc)  {\n        assert.ifError(err);\n        doc.arrData[0].set('subObj', { subName : 'modified subName' });\n        doc.save(function (err) {\n          assert.ifError(err);\n          AModel.findById(instance.id, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(doc.arrData[0].subObj.subName,'modified subName');\n            done();\n          });\n        });\n      });\n    });\n  })\n\n  it('saving an embedded document twice should not push that doc onto the parent doc twice (gh-267)', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection)\n      , post = new BlogPost();\n\n    post.comments.push({title: 'woot'});\n    post.save( function (err) {\n      assert.ifError(err);\n      assert.equal(1, post.comments.length);\n      BlogPost.findById(post.id, function (err, found) {\n        assert.ifError(err);\n        assert.equal(1, found.comments.length);\n        post.save( function (err) {\n          assert.ifError(err);\n          assert.equal(1, post.comments.length);\n          BlogPost.findById(post.id, function (err, found) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(1, found.comments.length);\n            done();\n          });\n        });\n      });\n    });\n  })\n\n  describe('embedded array filtering', function(){\n    it('by the id shortcut function', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost();\n\n      post.comments.push({ title: 'woot' });\n      post.comments.push({ title: 'aaaa' });\n\n      var subdoc1 = post.comments[0];\n      var subdoc2 = post.comments[1];\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPost.findById(post.get('_id'), function (err, doc) {\n          db.close();\n          assert.ifError(err);\n\n          // test with an objectid\n          assert.equal(doc.comments.id(subdoc1.get('_id')).title,'woot');\n\n          // test with a string\n          var id = DocumentObjectId.toString(subdoc2._id);\n          assert.equal(doc.comments.id(id).title,'aaaa');\n          done();\n        });\n      });\n    });\n\n    it('by the id with cast error', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost();\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPost.findById(post.get('_id'), function (err, doc) {\n          db.close();\n          assert.ifError(err);\n          assert.strictEqual(doc.comments.id(null), null);\n          done();\n        });\n      });\n    })\n\n    it('by the id shortcut with no match', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost();\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPost.findById(post.get('_id'), function (err, doc) {\n          db.close();\n          assert.ifError(err);\n          assert.strictEqual(doc.comments.id(new DocumentObjectId), null);\n          done();\n        });\n      });\n    });\n  });\n\n  it('removing a subdocument atomically', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost();\n    post.title = 'hahaha';\n    post.comments.push({ title: 'woot' });\n    post.comments.push({ title: 'aaaa' });\n\n    post.save(function (err) {\n      assert.ifError(err);\n\n      BlogPost.findById(post.get('_id'), function (err, doc) {\n        assert.ifError(err);\n\n        doc.comments[0].remove();\n        doc.save(function (err) {\n          assert.ifError(err);\n\n          BlogPost.findById(post.get('_id'), function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(1, doc.comments.length);\n            assert.equal(doc.comments[0].title,'aaaa');\n            done();\n          });\n        });\n      });\n    });\n  })\n\n  it('single pull embedded doc', function(done){\n    var db = start()\n    , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost();\n    post.title = 'hahaha';\n    post.comments.push({ title: 'woot' });\n    post.comments.push({ title: 'aaaa' });\n\n    post.save(function (err) {\n      assert.ifError(err);\n\n      BlogPost.findById(post.get('_id'), function (err, doc) {\n        assert.ifError(err);\n\n        doc.comments.pull(doc.comments[0]);\n        doc.comments.pull(doc.comments[0]);\n        doc.save(function (err) {\n          assert.ifError(err);\n\n          BlogPost.findById(post.get('_id'), function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(0, doc.comments.length);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  it('saving mixed data', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection)\n      , count = 3;\n\n    // string\n    var post = new BlogPost();\n    post.mixed = 'woot';\n    post.save(function (err) {\n      assert.ifError(err);\n\n      BlogPost.findById(post._id, function (err) {\n        assert.ifError(err);\n        if (--count) return;\n        db.close();\n        done();\n      });\n    });\n\n    // array\n    var post2 = new BlogPost();\n    post2.mixed = { name: \"mr bungle\", arr: [] };\n    post2.save(function (err) {\n      assert.ifError(err);\n\n      BlogPost.findById(post2._id, function (err, doc){\n        assert.ifError(err);\n\n        assert.equal(true, Array.isArray(doc.mixed.arr));\n\n        doc.mixed = [{foo: 'bar'}];\n        doc.save(function (err) {\n          assert.ifError(err);\n\n          BlogPost.findById(doc._id, function (err, doc){\n            assert.ifError(err);\n\n            assert.equal(true, Array.isArray(doc.mixed));\n            doc.mixed.push({ hello: 'world' });\n            doc.mixed.push([ 'foo', 'bar' ]);\n            doc.markModified('mixed');\n\n            doc.save(function (err, doc) {\n              assert.ifError(err);\n\n              BlogPost.findById(post2._id, function (err, doc) {\n                assert.ifError(err);\n\n                assert.deepEqual(doc.mixed[0],{ foo: 'bar' });\n                assert.deepEqual(doc.mixed[1],{ hello: 'world' });\n                assert.deepEqual(doc.mixed[2],['foo','bar']);\n                if (--count) return;\n                db.close();\n                done();\n              });\n            });\n          });\n\n          // date\n          var post3 = new BlogPost();\n          post3.mixed = new Date;\n          post3.save(function (err) {\n            assert.ifError(err);\n\n            BlogPost.findById(post3._id, function (err, doc) {\n              assert.ifError(err);\n              assert.ok(doc.mixed instanceof Date);\n              if (--count) return;\n              db.close();\n              done();\n            });\n          });\n        });\n      });\n    });\n  });\n\n  it('populating mixed data from the constructor (gh-200)', function(){\n    var db = start()\n      , BlogPost = db.model('BlogPost');\n\n    var post = new BlogPost({\n      mixed: {\n          type: 'test'\n        , github: 'rules'\n        , nested: {\n              number: 3\n          }\n      }\n    });\n\n    db.close();\n    assert.equal('test', post.mixed.type);\n    assert.equal('rules', post.mixed.github);\n    assert.equal(3, post.mixed.nested.number);\n  })\n\n  it('\"type\" is allowed as a key', function(done){\n    mongoose.model('TestTypeDefaults', new Schema({\n        type: { type: String, default: 'YES!' }\n    }));\n\n    var db = start()\n      , TestDefaults = db.model('TestTypeDefaults');\n\n    var post = new TestDefaults();\n    assert.equal(typeof post.get('type'),'string');\n    assert.equal(post.get('type'),'YES!');\n\n    // GH-402\n    var TestDefaults2 = db.model('TestTypeDefaults2', new Schema({\n        x: { y: { type: { type: String }, owner: String } }\n    }));\n\n    var post = new TestDefaults2;\n    post.x.y.type = \"#402\";\n    post.x.y.owner= \"me\";\n    post.save(function (err) {\n      db.close();\n      assert.ifError(err);\n      done();\n    });\n  })\n\n  it('unaltered model does not clear the doc (gh-195)', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost();\n    post.title = 'woot';\n    post.save(function (err) {\n      assert.ifError(err);\n\n      BlogPost.findById(post._id, function (err, doc) {\n        assert.ifError(err);\n\n        // we deliberately make no alterations\n        doc.save(function (err) {\n          assert.ifError(err);\n\n          BlogPost.findById(doc._id, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(doc.title,'woot');\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe('safe mode', function(){\n    it('works', function(done){\n      var Human = new Schema({\n          name  : String\n        , email : { type: String, index: { unique: true, background: false }}\n      });\n\n      mongoose.model('SafeHuman', Human, true);\n\n      var db = start()\n        , Human = db.model('SafeHuman', 'safehuman' + random());\n\n      Human.on('index', function (err) {\n        assert.ifError(err);\n        var me = new Human({\n            name  : 'Guillermo Rauch'\n          , email : 'rauchg@gmail.com'\n        });\n\n        me.save(function (err) {\n          assert.ifError(err);\n\n          Human.findById(me._id, function (err, doc){\n            assert.ifError(err);\n            assert.equal(doc.email,'rauchg@gmail.com');\n\n            var copycat = new Human({\n                name  : 'Lionel Messi'\n              , email : 'rauchg@gmail.com'\n            });\n\n            copycat.save(function (err) {\n              db.close();\n              assert.ok(/duplicate/.test(err.message));\n              assert.ok(err instanceof Error);\n              done();\n            });\n          });\n        });\n      });\n\n    });\n\n    it('can be disabled', function(done){\n      var Human = new Schema({\n          name  : String\n        , email : { type: String, index: { unique: true, background: false }}\n      });\n\n      // turn it off\n      Human.set('safe', false);\n\n      mongoose.model('UnsafeHuman', Human, true);\n\n      var db = start()\n        , Human = db.model('UnsafeHuman', 'unsafehuman' + random());\n\n      Human.on('index', function (err) {\n        assert.ifError(err);\n      });\n\n      var me = new Human({\n          name  : 'Guillermo Rauch'\n        , email : 'rauchg@gmail.com'\n      });\n\n      me.save(function (err) {\n        assert.ifError(err);\n\n        Human.findById(me._id, function (err, doc){\n          assert.ifError(err);\n          assert.equal(doc.email,'rauchg@gmail.com');\n\n          var copycat = new Human({\n              name  : 'Lionel Messi'\n            , email : 'rauchg@gmail.com'\n          });\n\n          copycat.save(function (err) {\n            db.close();\n            assert.ifError(err);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe('hooks', function(){\n    describe('pre', function(){\n      it('with undefined and null', function(done){\n        var db = start();\n        var schema = new Schema({ name: String });\n        var called = 0;\n\n        schema.pre('save', function (next) {\n          called++;\n          next(undefined);\n        });\n\n        schema.pre('save', function (next) {\n          called++;\n          next(null);\n        });\n\n        var S = db.model('S', schema, collection);\n        var s = new S({name: 'zupa'});\n\n        s.save(function (err) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(2, called);\n          done();\n        });\n      });\n\n      it('called on all sub levels', function(done){\n        var db = start();\n\n        var grandSchema = new Schema({ name : String });\n        grandSchema.pre('save', function (next) {\n          this.name = 'grand';\n          next();\n        });\n\n        var childSchema = new Schema({ name : String, grand : [grandSchema]});\n        childSchema.pre('save', function (next) {\n          this.name = 'child';\n          next();\n        });\n\n        var schema = new Schema({ name: String, child : [childSchema] });\n\n        schema.pre('save', function (next) {\n          this.name = 'parent';\n          next();\n        });\n\n        var S = db.model('presave_hook', schema, 'presave_hook');\n        var s = new S({ name : 'a' , child : [ { name : 'b', grand : [{ name : 'c'}] } ]});\n\n        s.save(function (err, doc) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(doc.name,'parent');\n          assert.equal(doc.child[0].name,'child');\n          assert.equal(doc.child[0].grand[0].name,'grand');\n          done();\n        });\n      });\n\n      it('error on any sub level', function(done){\n        var db = start();\n\n        var grandSchema = new Schema({ name : String });\n        grandSchema.pre('save', function (next) {\n          next(new Error('Error 101'));\n        });\n\n        var childSchema = new Schema({ name : String, grand : [grandSchema]});\n        childSchema.pre('save', function (next) {\n          this.name = 'child';\n          next();\n        });\n\n        var schema = new Schema({ name: String, child : [childSchema] });\n        schema.pre('save', function (next) {\n          this.name = 'parent';\n          next();\n        });\n\n        var S = db.model('presave_hook_error', schema, 'presave_hook_error');\n        var s = new S({ name : 'a' , child : [ { name : 'b', grand : [{ name : 'c'}] } ]});\n\n        s.save(function (err, doc) {\n          db.close();\n          assert.ok(err instanceof Error);\n          assert.equal(err.message,'Error 101');\n          done();\n        });\n      })\n\n      describe('init', function(){\n        it('has access to the true ObjectId when used with querying (gh-289)', function(done){\n          var db = start()\n            , PreInitSchema = new Schema({})\n            , preId = null\n\n          PreInitSchema.pre('init', function (next) {\n            preId = this._id;\n            next();\n          });\n\n          var PreInit = db.model('PreInit', PreInitSchema, 'pre_inits' + random());\n\n          var doc = new PreInit();\n          doc.save(function (err) {\n            assert.ifError(err);\n            PreInit.findById(doc._id, function (err, found) {\n              db.close();\n              assert.ifError(err);\n              assert.strictEqual(undefined, preId);\n              done();\n            });\n          });\n        })\n      })\n\n      it('should not work when calling next() after a thrown error', function(){\n        var db = start();\n\n        var s = new Schema({});\n        s.methods.funky = function () {\n          assert.strictEqual(false, true, 'reached unreachable code');\n        }\n\n        s.pre('funky', function (next) {\n          db.close();\n          try {\n            next(new Error);\n          } catch (error) {\n            // throws b/c nothing is listening to the db error event\n            assert.ok(error instanceof Error);\n            next();\n          }\n        });\n        var Kaboom = db.model('wowNext2xAndThrow', s, 'next2xAndThrow' + random());\n        new Kaboom().funky();\n      });\n\n    });\n\n    describe('post', function(){\n      it('works', function(done){\n        var schema = new Schema({\n                title: String\n            })\n          , save = false\n          , remove = false\n          , init = false\n          , post = undefined;\n\n        schema.post('save', function (arg) {\n          assert.equal(arg.id,post.id)\n          save = true;\n        });\n\n        schema.post('init', function () {\n          init = true;\n        });\n\n        schema.post('remove', function (arg) {\n          assert.equal(arg.id,post.id)\n          remove = true;\n        });\n\n        mongoose.model('PostHookTest', schema);\n\n        var db = start()\n          , BlogPost = db.model('PostHookTest');\n\n        post = new BlogPost();\n\n        post.save(function (err) {\n          process.nextTick(function () {\n            assert.ifError(err);\n            assert.ok(save);\n            BlogPost.findById(post._id, function (err, doc) {\n              process.nextTick(function () {\n                assert.ifError(err);\n                assert.ok(init);\n\n                doc.remove(function (err) {\n                  process.nextTick(function () {\n                    db.close();\n                    assert.ifError(err);\n                    assert.ok(remove);\n                    done();\n                  });\n                });\n              });\n            });\n          });\n\n        });\n\n      });\n\n      it('on embedded docs', function(done){\n        var save = false,\n            init = false,\n            remove = false;\n\n        var EmbeddedSchema = new Schema({\n          title : String\n        });\n\n        var ParentSchema = new Schema({\n          embeds : [EmbeddedSchema]\n        });\n\n        EmbeddedSchema.post('save', function(next){\n          save = true;\n        });\n\n        // Don't know how to test those on a embedded document.\n        //EmbeddedSchema.post('init', function () {\n          //init = true;\n        //});\n\n        //EmbeddedSchema.post('remove', function () {\n          //remove = true;\n        //});\n\n        mongoose.model('Parent', ParentSchema);\n\n        var db = start(),\n            Parent = db.model('Parent');\n\n        var parent = new Parent();\n\n        parent.embeds.push({title: 'Testing post hooks for embedded docs'});\n\n        parent.save(function(err){\n          db.close();\n          assert.ifError(err);\n          assert.ok(save);\n          done();\n        });\n      });\n    });\n\n  });\n\n  describe('#exec()', function(){\n    it('count()', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create({title: 'interoperable count as promise'}, function (err, created) {\n        assert.ifError(err);\n        var query = BlogPost.count({title: 'interoperable count as promise'});\n        query.exec(function (err, count) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(1, count);\n          done();\n        });\n      });\n    });\n\n    it('update()', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create({title: 'interoperable update as promise'}, function (err, created) {\n        assert.ifError(err);\n        var query = BlogPost.update({title: 'interoperable update as promise'}, {title: 'interoperable update as promise delta'});\n        query.exec(function (err) {\n          assert.ifError(err);\n          BlogPost.count({title: 'interoperable update as promise delta'}, function (err, count) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(1, count);\n            done();\n          });\n        });\n      });\n    });\n\n    it('findOne()', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create({title: 'interoperable findOne as promise'}, function (err, created) {\n        assert.ifError(err);\n        var query = BlogPost.findOne({title: 'interoperable findOne as promise'});\n        query.exec(function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(found.id,created.id);\n          done();\n        });\n      });\n    });\n\n    it('find()', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create(\n          {title: 'interoperable find as promise'}\n        , {title: 'interoperable find as promise'}\n        , function (err, createdOne, createdTwo) {\n        assert.ifError(err);\n        var query = BlogPost.find({title: 'interoperable find as promise'});\n        query.exec(function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(found.length,2);\n          assert.equal(found[0]._id.id,createdOne._id.id);\n          assert.equal(found[1]._id.id,createdTwo._id.id);\n          done();\n        });\n      });\n    });\n\n    it('remove()', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create(\n          {title: 'interoperable remove as promise'}\n        , function (err, createdOne, createdTwo) {\n        assert.ifError(err);\n        var query = BlogPost.remove({title: 'interoperable remove as promise'});\n        query.exec(function (err) {\n          assert.ifError(err);\n          BlogPost.count({title: 'interoperable remove as promise'}, function (err, count) {\n            db.close();\n            assert.equal(count, 0);\n            done();\n          });\n        });\n      });\n    });\n\n    it('op can be changed', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection)\n        , title = 'interop ad-hoc as promise';\n\n      BlogPost.create({title: title }, function (err, created) {\n        assert.ifError(err);\n        var query = BlogPost.count({title: title });\n        query.exec('findOne', function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(found.id,created.id);\n          done();\n        });\n      });\n    });\n\n    describe('promises', function(){\n      it('count()', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        BlogPost.create({title: 'interoperable count as promise 2'}, function (err, created) {\n          assert.ifError(err);\n          var query = BlogPost.count({title: 'interoperable count as promise 2'});\n          var promise = query.exec();\n          promise.addBack(function (err, count) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(1, count);\n            done();\n          });\n        });\n      });\n\n      it('update()', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        BlogPost.create({title: 'interoperable update as promise 2'}, function (err, created) {\n          assert.ifError(err);\n          var query = BlogPost.update({title: 'interoperable update as promise 2'}, {title: 'interoperable update as promise delta 2'});\n          var promise = query.exec();\n          promise.addBack(function (err) {\n            assert.ifError(err);\n            BlogPost.count({title: 'interoperable update as promise delta 2'}, function (err, count) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(1, count);\n              done();\n            });\n          });\n        });\n      });\n\n      it('findOne()', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        BlogPost.create({title: 'interoperable findOne as promise 2'}, function (err, created) {\n          assert.ifError(err);\n          var query = BlogPost.findOne({title: 'interoperable findOne as promise 2'});\n          var promise = query.exec();\n          promise.addBack(function (err, found) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(found.id,created.id);\n            done();\n          });\n        });\n      });\n\n      it('find()', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        BlogPost.create(\n            {title: 'interoperable find as promise 2'}\n          , {title: 'interoperable find as promise 2'}\n          , function (err, createdOne, createdTwo) {\n          assert.ifError(err);\n          var query = BlogPost.find({title: 'interoperable find as promise 2'}).sort('_id');\n          var promise = query.exec();\n          promise.addBack(function (err, found) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(found.length,2);\n            assert.equal(found[0].id,createdOne.id);\n            assert.equal(found[1].id,createdTwo.id);\n            done();\n          });\n        });\n      });\n\n      it('remove()', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        BlogPost.create(\n            {title: 'interoperable remove as promise 2'}\n          , function (err, createdOne, createdTwo) {\n          assert.ifError(err);\n          var query = BlogPost.remove({title: 'interoperable remove as promise 2'});\n          var promise = query.exec();\n          promise.addBack(function (err) {\n            assert.ifError(err);\n            BlogPost.count({title: 'interoperable remove as promise 2'}, function (err, count) {\n              db.close();\n              assert.equal(count,0);\n              done();\n            });\n          });\n        });\n      });\n\n      it('are compatible with op modification on the fly', function(done){\n        var db = start()\n          , BlogPost = db.model('BlogPost', collection);\n\n        BlogPost.create({title: 'interoperable ad-hoc as promise 2'}, function (err, created) {\n          assert.ifError(err);\n          var query = BlogPost.count({title: 'interoperable ad-hoc as promise 2'});\n          var promise = query.exec('findOne');\n          promise.addBack(function (err, found) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(found._id.id,created._id.id);\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe('profiling', function(){\n    it('system.profile is a default model', function(){\n      var Profile = mongoose.model('system.profile');\n      assert.equal('object', typeof Profile.schema.paths.ts);\n      assert.equal('object', typeof Profile.schema.paths.info);\n      assert.equal('object', typeof Profile.schema.paths.millis);\n      assert.equal('object', typeof Profile.schema.paths.op);\n      assert.equal('object', typeof Profile.schema.paths.ns);\n      assert.equal('object', typeof Profile.schema.paths.query);\n      assert.equal('object', typeof Profile.schema.paths.updateobj);\n      assert.equal('object', typeof Profile.schema.paths.ntoreturn);\n      assert.equal('object', typeof Profile.schema.paths.nreturned);\n      assert.equal('object', typeof Profile.schema.paths.nscanned);\n      assert.equal('object', typeof Profile.schema.paths.responseLength);\n      assert.equal('object', typeof Profile.schema.paths.client);\n      assert.equal('object', typeof Profile.schema.paths.user);\n      assert.equal('object', typeof Profile.schema.paths.idhack);\n      assert.equal('object', typeof Profile.schema.paths.scanAndOrder);\n      assert.equal('object', typeof Profile.schema.paths.keyUpdates);\n      assert.strictEqual(undefined, Profile.schema.paths._id);\n      assert.strictEqual(undefined, Profile.schema.virtuals.id);\n\n      var db = start();\n      Profile = db.model('system.profile');\n      db.close();\n      assert.equal('object', typeof Profile.schema.paths.ts);\n      assert.equal('object', typeof Profile.schema.paths.info);\n      assert.equal('object', typeof Profile.schema.paths.millis);\n      assert.equal('object', typeof Profile.schema.paths.op);\n      assert.equal('object', typeof Profile.schema.paths.ns);\n      assert.equal('object', typeof Profile.schema.paths.query);\n      assert.equal('object', typeof Profile.schema.paths.updateobj);\n      assert.equal('object', typeof Profile.schema.paths.ntoreturn);\n      assert.equal('object', typeof Profile.schema.paths.nreturned);\n      assert.equal('object', typeof Profile.schema.paths.nscanned);\n      assert.equal('object', typeof Profile.schema.paths.responseLength);\n      assert.equal('object', typeof Profile.schema.paths.client);\n      assert.equal('object', typeof Profile.schema.paths.user);\n      assert.equal('object', typeof Profile.schema.paths.idhack);\n      assert.equal('object', typeof Profile.schema.paths.scanAndOrder);\n      assert.equal('object', typeof Profile.schema.paths.keyUpdates);\n      assert.strictEqual(undefined, Profile.schema.paths._id);\n      assert.strictEqual(undefined, Profile.schema.virtuals.id);\n\n      // can override the default\n      db = start();\n      // reset Mongoose state\n      delete db.base.modelSchemas['system.profile']\n      delete db.base.models['system.profile']\n      delete db.models['system.profile'];\n      db.close();\n      // test\n      var over = db.model('system.profile', new Schema({ name: String }));\n      assert.equal('object', typeof over.schema.paths.name);\n      assert.strictEqual(undefined, over.schema.paths.ts);\n      // reset\n      delete db.base.modelSchemas['system.profile']\n      delete db.base.models['system.profile']\n      delete db.models['system.profile'];\n    });\n\n    it('level can be set', function(done){\n      var db = start();\n      db.setProfiling(3, function (err) {\n        assert.equal(err.message,'Invalid profiling level: 3');\n        db.setProfiling('fail', function (err) {\n          assert.equal(err.message,'Invalid profiling level: fail');\n          db.setProfiling(2, function (err, doc) {\n            assert.ifError(err);\n            db.setProfiling(1, 50, function (err, doc) {\n              assert.ifError(err);\n              assert.equal(2, doc.was);\n              db.setProfiling(0, function (err, doc) {\n                db.close();\n                assert.ifError(err);\n                assert.equal(1, doc.was);\n                assert.equal(50, doc.slowms);\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n\n  describe('console.log', function(){\n    it('hides private props', function(){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var date = new Date(1305730951086);\n      var id0 = new DocumentObjectId('4dd3e169dbfb13b4570000b9');\n      var id1 = new DocumentObjectId('4dd3e169dbfb13b4570000b6');\n      var id2 = new DocumentObjectId('4dd3e169dbfb13b4570000b7');\n      var id3 = new DocumentObjectId('4dd3e169dbfb13b4570000b8');\n\n      var post = new BlogPost({\n          title: 'Test'\n        , _id: id0\n        , date: date\n        , numbers: [5,6,7]\n        , owners: [id1]\n        , meta: { visitors: 45 }\n        , comments: [\n            { _id: id2, title: 'my comment', date: date, body: 'this is a comment' },\n            { _id: id3, title: 'the next thang', date: date, body: 'this is a comment too!' }]\n      });\n\n      db.close();\n\n      var a = '{ meta: { visitors: 45 },\\n  numbers: [ 5, 6, 7 ],\\n  owners: [ 4dd3e169dbfb13b4570000b6 ],\\n  comments: \\n   [{ _id: 4dd3e169dbfb13b4570000b7,\\n     comments: [],\\n     body: \\'this is a comment\\',\\n     date: Wed, 18 May 2011 15:02:31 GMT,\\n     title: \\'my comment\\' }\\n   { _id: 4dd3e169dbfb13b4570000b8,\\n     comments: [],\\n     body: \\'this is a comment too!\\',\\n     date: Wed, 18 May 2011 15:02:31 GMT,\\n     title: \\'the next thang\\' }],\\n  _id: 4dd3e169dbfb13b4570000b9,\\n  date: Wed, 18 May 2011 15:02:31 GMT,\\n  title: \\'Test\\' }'\n\n      var out = post.inspect();\n      assert.ok(/meta: { visitors: 45 }/.test(out));\n      assert.ok(/numbers: \\[ 5, 6, 7 \\]/.test(out));\n      assert.ok(/Wed.+ 2011 \\d\\d:02:31 GMT/.test(out));\n      assert.ok(!/activePaths:/.test(out));\n      assert.ok(!/_atomics:/.test(out));\n    });\n  })\n\n  describe('pathnames', function(){\n    it('named path can be used', function(){\n      var db = start()\n        , P = db.model('pathnametest', new Schema({ path: String }))\n      db.close();\n\n      var threw = false;\n      try {\n        new P({ path: 'i should not throw' });\n      } catch (err) {\n        threw = true;\n      }\n\n      assert.ok(!threw);\n    })\n  })\n\n  describe('auto_reconnect', function(){\n    describe('if disabled', function(){\n      describe('with mongo down', function(){\n        it('should pass an error', function(done){\n          var db = start({ server: { auto_reconnect: false }});\n          var T = db.model('Thing', new Schema({ type: String }));\n          db.on('open', function () {\n            var t = new T({ type: \"monster\" });\n\n            var worked = false;\n            t.save(function (err) {\n              assert.equal(err.message, 'no open connections');\n              worked = true;\n            });\n\n            db.db.close();\n\n            setTimeout(function () {\n              assert.ok(worked);\n              done();\n            }, 500);\n          });\n        });\n      });\n    });\n  });\n\n  it('subdocuments with changed values should persist the values', function(done){\n    var db = start()\n    var Subdoc = new Schema({ name: String, mixed: Schema.Types.Mixed });\n    var T = db.model('SubDocMixed', new Schema({ subs: [Subdoc] }));\n\n    var t = new T({ subs: [{ name: \"Hubot\", mixed: { w: 1, x: 2 }}] });\n    assert.equal(t.subs[0].name,\"Hubot\");\n    assert.equal(t.subs[0].mixed.w,1);\n    assert.equal(t.subs[0].mixed.x,2);\n\n    t.save(function (err) {\n      assert.ifError(err);\n\n      T.findById(t._id, function (err, t) {\n        assert.ifError(err);\n        assert.equal(t.subs[0].name,\"Hubot\");\n        assert.equal(t.subs[0].mixed.w,1);\n        assert.equal(t.subs[0].mixed.x,2);\n\n        var sub = t.subs[0];\n        sub.name = \"Hubot1\";\n        assert.equal(sub.name,\"Hubot1\");\n        assert.ok(sub.isModified('name'));\n        assert.ok(t.isModified());\n\n        t.save(function (err) {\n          assert.ifError(err);\n\n          T.findById(t._id, function (err, t) {\n            assert.ifError(err);\n            assert.strictEqual(t.subs[0].name, \"Hubot1\");\n\n            var sub = t.subs[0];\n            sub.mixed.w = 5;\n            assert.equal(sub.mixed.w,5);\n            assert.ok(!sub.isModified('mixed'));\n            sub.markModified('mixed');\n            assert.ok(sub.isModified('mixed'));\n            assert.ok(sub.isModified());\n            assert.ok(t.isModified());\n\n            t.save(function (err) {\n              assert.ifError(err);\n\n              T.findById(t._id, function (err, t) {\n                db.close();\n                assert.ifError(err);\n                assert.strictEqual(t.subs[0].mixed.w, 5);\n                done();\n              })\n            })\n          });\n        });\n      })\n    })\n  })\n\n  describe('RegExps', function(){\n    it('can be saved', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      var post = new BlogPost({ mixed: { rgx: /^asdf$/ } });\n      assert.ok(post.mixed.rgx instanceof RegExp);\n      assert.equal(post.mixed.rgx.source,'^asdf$');\n      post.save(function (err) {\n        assert.ifError(err);\n        BlogPost.findById(post._id, function (err, post) {\n          db.close();\n          assert.ifError(err);\n          assert.ok(post.mixed.rgx instanceof RegExp);\n          assert.equal(post.mixed.rgx.source,'^asdf$');\n          done();\n        });\n      });\n    });\n  })\n\n  // Demonstration showing why GH-261 is a misunderstanding\n  it('a single instantiated document should be able to update its embedded documents more than once', function(done){\n    var db = start()\n      , BlogPost = db.model('BlogPost', collection);\n\n    var post = new BlogPost();\n    post.comments.push({title: 'one'});\n    post.save(function (err) {\n      assert.ifError(err);\n      assert.equal(post.comments[0].title,'one');\n      post.comments[0].title = 'two';\n      assert.equal(post.comments[0].title,'two');\n      post.save(function (err) {\n        assert.ifError(err);\n        BlogPost.findById(post._id, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(found.comments[0].title,'two');\n          done();\n        });\n      });\n    });\n  })\n\n  describe('save()', function(){\n    describe('when no callback is passed', function(){\n      it('should emit error on its db', function(done){\n        var db = start();\n\n        db.on('error', function (err) {\n          db.close();\n          assert.ok(err instanceof Error);\n          done();\n        });\n\n        var DefaultErrSchema = new Schema({});\n        DefaultErrSchema.pre('save', function (next) {\n          next(new Error);\n        });\n        var DefaultErr = db.model('DefaultErr2', DefaultErrSchema, 'default_err_' + random());\n        new DefaultErr().save();\n      })\n\n      it('should emit error on its Model when there are listeners', function(done){\n        var db = start();\n\n        var DefaultErrSchema = new Schema({});\n        DefaultErrSchema.pre('save', function (next) {\n          next(new Error);\n        });\n\n        var DefaultErr = db.model('DefaultErr3', DefaultErrSchema, 'default_err_' + random());\n\n        DefaultErr.on('error', function (err) {\n          db.close();\n          assert.ok(err instanceof Error);\n          done();\n        });\n\n        new DefaultErr().save();\n      })\n\n      it('should throw error when nothing is listening to db or Model errors', function(done){\n        var db = start({ noErrorListener: 1 });\n\n        var DefaultErrSchema = new Schema({});\n        DefaultErrSchema.pre('save', function (next) {\n          try {\n            next(new Error);\n          } catch (error) {\n            // throws b/c nothing is listening to the Model or db error event\n            db.close();\n            assert.ok(error instanceof Error);\n            done();\n          }\n        });\n        var DefaultErr = db.model('DefaultErr1', DefaultErrSchema, 'default_err_' + random());\n        new DefaultErr().save();\n      });\n    });\n    it('returns number of affected docs', function(done){\n      var db = start()\n      var schema = new Schema({ name: String });\n      var S = db.model('AffectedDocsAreReturned', schema);\n      var s = new S({ name: 'aaron' });\n      s.save(function (err, doc, affected) {\n        assert.ifError(err);\n        assert.equal(1, affected);\n        s.name = 'heckmanananananana';\n        s.save(function (err, doc, affected) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(1, affected);\n          done();\n        });\n      });\n    })\n    it('saved changes made within callback of a previous no-op save gh-1139', function(done){\n      var db = start()\n        , B = db.model('BlogPost', collection);\n\n      var post = new B({ title: 'first' });\n      post.save(function (err) {\n        assert.ifError(err);\n\n        // no op\n        post.save(function (err) {\n          assert.ifError(err);\n\n          post.title = 'changed';\n          post.save(function (err) {\n            assert.ifError(err);\n\n            B.findById(post, function (err, doc) {\n              assert.ifError(err);\n              assert.equal('changed', doc.title);\n              done();\n            })\n          })\n        })\n      })\n    })\n\n  });\n\n  describe('_delta()', function(){\n    it('should overwrite arrays when directly set (gh-1126)', function(done){\n      var db = start()\n        , B = db.model('BlogPost', collection);\n\n      B.create({ title: 'gh-1126', numbers: [1,2] }, function (err, b) {\n        assert.ifError(err);\n        B.findById(b._id, function (err, b) {\n          assert.ifError(err);\n          assert.deepEqual([1,2].join(), b.numbers.join());\n\n          b.numbers = [];\n          b.numbers.push(3);\n\n          var d = b._delta()[1];\n          assert.ok('$set' in d, 'invalid delta ' + JSON.stringify(d));\n          assert.ok(Array.isArray(d.$set.numbers));\n          assert.equal(d.$set.numbers.length, 1);\n          assert.equal(d.$set.numbers[0], 3);\n\n          b.save(function (err) {\n            assert.ifError(err);\n\n            B.findById(b._id, function (err, b) {\n              assert.ifError(err);\n              assert.ok(Array.isArray(b.numbers));\n              assert.equal(1, b.numbers.length);\n              assert.equal(3, b.numbers[0]);\n\n              b.numbers = [3];\n              var d = b._delta();\n              assert.ok(!d);\n\n              b.numbers = [4];\n              b.numbers.push(5);\n              b.save(function (err) {\n                assert.ifError(err);\n                B.findById(b._id, function (err, b) {\n                  assert.ifError(err);\n                  assert.ok(Array.isArray(b.numbers));\n                  assert.equal(2, b.numbers.length);\n                  assert.equal(4, b.numbers[0]);\n                  assert.equal(5, b.numbers[1]);\n                  done();\n                })\n              })\n            })\n          })\n        })\n      });\n    })\n  })\n\n  describe('backward compatibility', function(){\n    it('with conflicted data in db', function(done){\n      var db = start();\n      var M = db.model('backwardDataConflict', new Schema({ namey: { first: String, last: String }}));\n      var m = new M({ namey: \"[object Object]\" });\n      m.namey = { first: 'GI', last: 'Joe' };// <-- should overwrite the string\n      m.save(function (err) {\n        db.close();\n        assert.strictEqual(err, null);\n        assert.strictEqual('GI', m.namey.first);\n        assert.strictEqual('Joe', m.namey.last);\n        done();\n      });\n    });\n\n    it('with positional notation on path not existing in schema (gh-1048)', function(done){\n      var db = start();\n\n      var M = db.model('backwardCompat-gh-1048', Schema({ name: 'string' }));\n      db.on('open', function () {\n        var o = {\n            name: 'gh-1048'\n          , _id: new mongoose.Types.ObjectId\n          , databases: {\n                0: { keys: 100, expires: 0}\n              , 15: {keys:1,expires:0}\n            }\n        };\n\n        M.collection.insert(o, { safe: true }, function (err) {\n          assert.ifError(err);\n          M.findById(o._id, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.ok(doc);\n            assert.ok(doc._doc.databases);\n            assert.ok(doc._doc.databases['0']);\n            assert.ok(doc._doc.databases['15']);\n            assert.equal(undefined, doc.databases);\n            done();\n          })\n        })\n      });\n    })\n  });\n\n  describe('create()', function(){\n    it('accepts an array', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create([{ title: 'hi'}, { title: 'bye'}], function (err, post1, post2) {\n        db.close();\n        assert.strictEqual(err, null);\n        assert.ok(post1.get('_id') instanceof DocumentObjectId);\n        assert.ok(post2.get('_id') instanceof DocumentObjectId);\n\n        assert.equal(post1.title,'hi');\n        assert.equal(post2.title,'bye');\n        done();\n      });\n    });\n\n    it('fires callback when passed 0 docs', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create(function (err, a) {\n        db.close();\n        assert.strictEqual(err, null);\n        assert.ok(!a);\n        done();\n      });\n    });\n\n    it('fires callback when empty array passed', function(done){\n      var db = start()\n        , BlogPost = db.model('BlogPost', collection);\n\n      BlogPost.create([], function (err, a) {\n        db.close();\n        assert.strictEqual(err, null);\n        assert.ok(!a);\n        done();\n      });\n    });\n  });\n\n  describe('non-schema adhoc property assignments', function(){\n    it('are not saved', function(done){\n      var db = start()\n        , B = db.model('BlogPost', collection)\n\n      var b = new B;\n      b.whateveriwant = 10;\n      b.save(function (err) {\n        assert.ifError(err);\n        B.collection.findOne({ _id: b._id }, function (err, doc) {\n          db.close();\n          assert.ifError(err);\n          assert.ok(!('whateveriwant' in doc));\n          done();\n        });\n      });\n    });\n  })\n\n  it('should not throw range error when using Number _id and saving existing doc (gh-691)', function(done){\n    var db =start();\n    var T = new Schema({ _id: Number, a: String });\n    var D = db.model('Testing691', T, 'asdf' + random());\n    var d = new D({ _id: 1 });\n    d.save(function (err) {\n      assert.ifError(err);\n\n      D.findById(d._id, function (err, d) {\n        assert.ifError(err);\n\n        d.a = 'yo';\n        d.save(function (err) {\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      });\n    });\n  });\n\n  describe('setting an unset value', function(){\n    it('is saved (gh-742)', function(done){\n      var db = start();\n\n      var DefaultTestObject = db.model(\"defaultTestObject\",\n        new Schema({\n          score:{type:Number, \"default\":55}\n        })\n      );\n\n      var myTest = new DefaultTestObject();\n\n      myTest.save(function (err, doc){\n        assert.ifError(err);\n        assert.equal(doc.score, 55);\n\n        DefaultTestObject.findById(doc._id, function (err, doc){\n          assert.ifError(err);\n\n          doc.score = undefined; // unset\n          doc.save(function (err, doc, count){\n            assert.ifError(err);\n\n            DefaultTestObject.findById(doc._id, function (err, doc){\n              assert.ifError(err);\n\n              doc.score = 55;\n              doc.save(function (err, doc, count){\n                db.close();\n                assert.ifError(err);\n                assert.equal(doc.score, 55);\n                assert.equal(count, 1);\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  })\n\n  it('path is cast to correct value when retreived from db', function(done){\n    var db = start();\n    var schema = new Schema({ title: { type: 'string', index: true }});\n    var T = db.model('T', schema);\n    T.collection.insert({ title: 234 }, {safe:true}, function (err) {\n      assert.ifError(err);\n      T.findOne(function (err, doc) {\n        db.close();\n        assert.ifError(err);\n        assert.equal('234', doc.title);\n        done();\n      });\n    });\n  });\n\n  it('setting a path to undefined should retain the value as undefined', function (done) {\n    var db = start()\n      , B = db.model('BlogPost', collection + random())\n\n    var doc = new B;\n    doc.title='css3';\n    assert.equal(doc._delta()[1].$set.title,'css3');\n    doc.title = undefined;\n    assert.equal(doc._delta()[1].$unset.title,1);\n    assert.strictEqual(undefined, doc._delta()[1].$set);\n\n    doc.title='css3';\n    doc.author = 'aaron';\n    doc.numbers = [3,4,5];\n    doc.meta.date = new Date;\n    doc.meta.visitors = 89;\n    doc.comments = [{ title: 'thanksgiving', body: 'yuuuumm' }];\n    doc.comments.push({ title: 'turkey', body: 'cranberries' });\n\n    doc.save(function (err) {\n      assert.ifError(err);\n      B.findById(doc._id, function (err, b) {\n        assert.ifError(err);\n        assert.equal(b.title,'css3');\n        assert.equal(b.author,'aaron');\n        assert.equal(b.meta.date.toString(), doc.meta.date.toString());\n        assert.equal(b.meta.visitors.valueOf(), doc.meta.visitors.valueOf());\n        assert.equal(2, b.comments.length);\n        assert.equal(b.comments[0].title, 'thanksgiving');\n        assert.equal(b.comments[0].body, 'yuuuumm');\n        assert.equal(b.comments[1].title,'turkey');\n        assert.equal(b.comments[1].body,'cranberries');\n        b.title = undefined;\n        b.author = null;\n        b.meta.date = undefined;\n        b.meta.visitors = null;\n        b.comments[0].title = null;\n        b.comments[0].body = undefined;\n        b.save(function (err) {\n          assert.ifError(err);\n          B.findById(b._id, function (err, b) {\n            assert.ifError(err);\n            assert.strictEqual(undefined, b.title);\n            assert.strictEqual(null, b.author);\n\n            assert.strictEqual(undefined, b.meta.date);\n            assert.strictEqual(null, b.meta.visitors);\n            assert.strictEqual(null, b.comments[0].title);\n            assert.strictEqual(undefined, b.comments[0].body);\n            assert.equal(b.comments[1].title,'turkey');\n            assert.equal(b.comments[1].body,'cranberries');\n\n            b.meta = undefined;\n            b.comments = undefined;\n            b.save(function (err) {\n              assert.ifError(err);\n              B.collection.findOne({ _id: b._id}, function (err, b) {\n                db.close();\n                assert.ifError(err);\n                assert.strictEqual(undefined, b.meta);\n                assert.strictEqual(undefined, b.comments);\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n  })\n\n  describe('unsetting a default value', function(){\n    it('should be ignored (gh-758)', function(done){\n      var db = start();\n      var M = db.model('758', new Schema({ s: String, n: Number, a: Array }));\n      M.collection.insert({ }, { safe: true }, function (err) {\n        assert.ifError(err);\n        M.findOne(function (err, m) {\n          assert.ifError(err);\n          m.s = m.n = m.a = undefined;\n          assert.equal(undefined, m._delta());\n          done();\n        });\n      });\n    })\n  })\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":127596}]],"length":127596}
