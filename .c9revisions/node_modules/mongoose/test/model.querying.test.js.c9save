{"ts":1352899780924,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/**\n * Test dependencies.\n */\n\nvar start = require('./common')\n  , assert = require('assert')\n  , mongoose = start.mongoose\n  , random = require('../lib/utils').random\n  , Query = require('../lib/query')\n  , Schema = mongoose.Schema\n  , SchemaType = mongoose.SchemaType\n  , CastError = SchemaType.CastError\n  , ObjectId = Schema.ObjectId\n  , MongooseBuffer = mongoose.Types.Buffer\n  , DocumentObjectId = mongoose.Types.ObjectId;\n\n/**\n * Setup.\n */\n\nvar Comments = new Schema;\n\nComments.add({\n    title     : String\n  , date      : Date\n  , body      : String\n  , comments  : [Comments]\n});\n\nvar BlogPostB = new Schema({\n    title     : String\n  , author    : String\n  , slug      : String\n  , date      : Date\n  , meta      : {\n        date      : Date\n      , visitors  : Number\n    }\n  , published : Boolean\n  , mixed     : {}\n  , numbers   : [Number]\n  , tags      : [String]\n  , sigs      : [Buffer]\n  , owners    : [ObjectId]\n  , comments  : [Comments]\n  , def       : { type: String, default: 'kandinsky' }\n});\n\nmongoose.model('BlogPostB', BlogPostB);\nvar collection = 'blogposts_' + random();\n\nvar ModSchema = new Schema({\n    num: Number\n  , str: String\n});\nmongoose.model('Mod', ModSchema);\n\nvar geoSchema = new Schema({ loc: { type: [Number], index: '2d'}});\n\ndescribe('model: querying:', function(){\n  it('find returns a Query', function(){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection);\n\n    // query\n    assert.ok(BlogPostB.find({}) instanceof Query);\n\n    // query, fields\n    assert.ok(BlogPostB.find({}, {}) instanceof Query);\n\n    // query, fields (empty string)\n    assert.ok(BlogPostB.find({}, '') instanceof Query);\n\n    // query, fields, options\n    assert.ok(BlogPostB.find({}, {}, {}) instanceof Query);\n\n    // query, fields (null), options\n    assert.ok(BlogPostB.find({}, null, {}) instanceof Query);\n\n    db.close();\n  });\n\n  it('findOne returns a Query', function(){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection);\n\n    // query\n    assert.ok(BlogPostB.findOne({}) instanceof Query);\n\n    // query, fields\n    assert.ok(BlogPostB.findOne({}, {}) instanceof Query);\n\n    // query, fields (empty string)\n    assert.ok(BlogPostB.findOne({}, '') instanceof Query);\n\n    // query, fields, options\n    assert.ok(BlogPostB.findOne({}, {}, {}) instanceof Query);\n\n    // query, fields (null), options\n    assert.ok(BlogPostB.findOne({}, null, {}) instanceof Query);\n\n    db.close();\n  });\n\n  it('an empty find does not hang', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n\n    function fn () {\n      db.close();\n      done();\n    };\n\n    BlogPostB.find({}, fn);\n  });\n\n  it('a query is executed when a callback is passed', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n      , count = 5\n      , q =  { _id: new DocumentObjectId }; // make sure the query is fast\n\n    function fn () {\n      if (--count) return;\n      db.close();\n      done();\n    };\n\n    // query\n    assert.ok(BlogPostB.find(q, fn) instanceof Query);\n\n    // query, fields (object)\n    assert.ok(BlogPostB.find(q, {}, fn) instanceof Query);\n\n    // query, fields (null)\n    assert.ok(BlogPostB.find(q, null, fn) instanceof Query);\n\n    // query, fields, options\n    assert.ok(BlogPostB.find(q, {}, {}, fn) instanceof Query);\n\n    // query, fields (''), options\n    assert.ok(BlogPostB.find(q, '', {}, fn) instanceof Query);\n  });\n\n  it('query is executed where a callback for findOne', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n      , count = 5\n      , q =  { _id: new DocumentObjectId }; // make sure the query is fast\n\n    function fn () {\n      if (--count) return;\n      db.close();\n      done();\n    };\n\n    // query\n    assert.ok(BlogPostB.findOne(q, fn) instanceof Query);\n\n    // query, fields\n    assert.ok(BlogPostB.findOne(q, {}, fn) instanceof Query);\n\n    // query, fields (empty string)\n    assert.ok(BlogPostB.findOne(q, '', fn) instanceof Query);\n\n    // query, fields, options\n    assert.ok(BlogPostB.findOne(q, {}, {}, fn) instanceof Query);\n\n    // query, fields (null), options\n    assert.ok(BlogPostB.findOne(q, null, {}, fn) instanceof Query);\n  });\n\n  describe('count', function(){\n    it('returns a Query', function(){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n      assert.ok(BlogPostB.count({}) instanceof Query);\n      db.close();\n    });\n\n    it('Query executes when you pass a callback', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , pending = 2\n\n      function fn () {\n        if (--pending) return;\n        db.close();\n        done();\n      };\n\n      assert.ok(BlogPostB.count({}, fn) instanceof Query);\n      assert.ok(BlogPostB.count(fn) instanceof Query);\n    });\n\n    it('counts documents', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , title = 'Wooooot ' + random();\n\n      var post = new BlogPostB();\n      post.set('title', title);\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var post = new BlogPostB();\n        post.set('title', title);\n\n        post.save(function (err) {\n          assert.ifError(err);\n\n          BlogPostB.count({ title: title }, function (err, count) {\n            assert.ifError(err);\n\n            assert.equal('number', typeof count);\n            assert.equal(2, count);\n\n            db.close();\n            done();\n          });\n        });\n      });\n    })\n  });\n\n  describe('distinct', function(){\n    it('returns a Query', function(){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      assert.ok(BlogPostB.distinct('title', {}) instanceof Query);\n      db.close();\n    });\n\n    it('executes when you pass a callback', function(done){\n      var db = start();\n      var Address = new Schema({ zip: String });\n      Address = db.model('Address', Address, 'addresses_' + random());\n\n      Address.create({ zip: '10010'}, { zip: '10010'}, { zip: '99701'}, function (err, a1, a2, a3) {\n        assert.strictEqual(null, err);\n        var query = Address.distinct('zip', {}, function (err, results) {\n          assert.ifError(err);\n          assert.deepEqual(results, ['10010', '99701']);\n          db.close();\n          done();\n        });\n        assert.ok(query instanceof Query);\n      });\n    });\n  });\n\n  describe('update', function(){\n    it('returns a Query', function(){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      assert.ok(BlogPostB.update({}, {}) instanceof Query);\n      assert.ok(BlogPostB.update({}, {}, {}) instanceof Query);\n      db.close();\n    });\n\n    it('Query executes when you pass a callback', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , count = 2;\n\n      function fn () {\n        if (--count) return;\n        db.close();\n        done();\n      };\n\n      assert.ok(BlogPostB.update({title: random()}, {}, fn) instanceof Query);\n      assert.ok(BlogPostB.update({title: random()}, {}, {}, fn) instanceof Query);\n    })\n  });\n\n  describe('findOne', function () {\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , title = 'Wooooot ' + random();\n\n      var post = new BlogPostB();\n      post.set('title', title);\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.findOne({ title: title }, function (err, doc) {\n          assert.ifError(err);\n          assert.equal(title, doc.get('title'));\n          assert.equal(false, doc.isNew);\n\n          db.close();\n          done();\n        });\n      });\n    });\n\n    it('casts $modifiers', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , post = new BlogPostB({\n            meta: {\n              visitors: -10\n            }\n          });\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var query = { 'meta.visitors': { $gt: '-20', $lt: -1 }};\n        BlogPostB.findOne(query, function (err, found) {\n          assert.ifError(err);\n          assert.ok(found);\n          assert.equal(found.get('meta.visitors').valueOf(), post.get('meta.visitors').valueOf());\n          found.id; // trigger caching\n          assert.equal(found.get('_id').toString(), post.get('_id'));\n          db.close();\n          done();\n        });\n      });\n    })\n\n    it('querying if an array contains one of multiple members $in a set', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      var post = new BlogPostB();\n\n      post.tags.push('football');\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.findOne({tags: {$in: ['football', 'baseball']}}, function (err, doc) {\n          assert.ifError(err);\n          assert.equal(doc._id.toString(),post._id);\n\n          BlogPostB.findOne({ _id: post._id, tags: /otba/i }, function (err, doc) {\n            assert.ifError(err);\n            assert.equal(doc._id.toString(),post._id);\n            db.close();\n            done();\n          });\n        });\n      });\n    });\n\n    it('querying if an array contains one of multiple members $in a set 2', function(done){\n      var db = start()\n        , BlogPostA = db.model('BlogPostB', collection)\n\n      var post = new BlogPostA({ tags: ['gooberOne'] });\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var query = {tags: {$in:[ 'gooberOne' ]}};\n\n        BlogPostA.findOne(query, function (err, returned) {\n          cb();\n          assert.ifError(err);\n          assert.ok(!!~returned.tags.indexOf('gooberOne'));\n          assert.equal(returned._id.toString(), post._id);\n        });\n      });\n\n      post.collection.insert({ meta: { visitors: 9898, a: null } }, {}, function (err, b) {\n        assert.ifError(err);\n\n        BlogPostA.findOne({_id: b[0]._id}, function (err, found) {\n          cb();\n          assert.ifError(err);\n          assert.equal(found.get('meta.visitors'), 9898);\n        });\n      });\n\n      var pending = 2;\n      function cb () {\n        if (--pending) return;\n        db.close();\n        done();\n      }\n    })\n\n    it('querying via $where a string', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({ title: 'Steve Jobs', author: 'Steve Jobs'}, function (err, created) {\n        assert.ifError(err);\n\n        BlogPostB.findOne({ $where: \"this.title && this.title === this.author\" }, function (err, found) {\n          assert.ifError(err);\n\n          assert.equal(found._id.toString(),created._id);\n          db.close();\n          done();\n        });\n      });\n    });\n\n    it('querying via $where a function', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({ author: 'Atari', slug: 'Atari'}, function (err, created) {\n        assert.ifError(err);\n\n        BlogPostB.findOne({ $where: function () {\n          return (this.author && this.slug && this.author === this.slug);\n        } }, function (err, found) {\n          assert.ifError(err);\n\n          assert.equal(found._id.toString(), created._id);\n          db.close();\n          done();\n        });\n      });\n    })\n\n    it('based on nested fields', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , post = new BlogPostB({\n            meta: {\n              visitors: 5678\n            }\n          });\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.findOne({ 'meta.visitors': 5678 }, function (err, found) {\n          assert.ifError(err);\n          assert.equal(found.get('meta.visitors')\n            .valueOf(), post.get('meta.visitors').valueOf());\n          assert.equal(found.get('_id').toString(), post.get('_id'));\n          db.close();\n          done();\n        });\n      });\n    })\n\n    it('based on embedded doc fields (gh-242, gh-463)', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({comments: [{title: 'i should be queryable'}], numbers: [1,2,33333], tags:['yes', 'no']}, function (err, created) {\n        assert.ifError(err);\n        BlogPostB.findOne({'comments.title': 'i should be queryable'}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(found._id.toString(), created._id);\n\n          BlogPostB.findOne({'comments.0.title': 'i should be queryable'}, function (err, found) {\n            assert.ifError(err);\n            assert.equal(found._id.toString(), created._id);\n\n            // GH-463\n            BlogPostB.findOne({'numbers.2': 33333}, function (err, found) {\n              assert.ifError(err);\n              assert.equal(found._id.toString(), created._id);\n\n              BlogPostB.findOne({'tags.1': 'no'}, function (err, found) {\n                assert.ifError(err);\n                assert.equal(found._id.toString(), created._id);\n                db.close();\n                done();\n              });\n            });\n          });\n        });\n      });\n    })\n\n    it('works with nested docs and string ids (gh-389)', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({comments: [{title: 'i should be queryable by _id'}, {title:'me too me too!'}]}, function (err, created) {\n        assert.ifError(err);\n        var id = created.comments[1]._id.toString();\n        BlogPostB.findOne({'comments._id': id}, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.strictEqual(!! found, true, 'Find by nested doc id hex string fails');\n          assert.equal(found._id.toString(), created._id);\n          done();\n        });\n      });\n    })\n\n    it('using #all with nested #elemMatch', function(done){\n      var db = start()\n        , P = db.model('BlogPostB', collection + '_nestedElemMatch');\n\n      var post = new P({ title: \"nested elemMatch\" });\n      post.comments.push({ title: 'comment A' }, { title: 'comment B' }, { title: 'comment C' })\n\n      var id0 = post.comments[0]._id;\n      var id1 = post.comments[1]._id;\n      var id2 = post.comments[2]._id;\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var query0 = { $elemMatch: { _id: id1, title: 'comment B' }};\n        var query1 = { $elemMatch: { _id: id2.toString(), title: 'comment C' }};\n\n        P.findOne({ comments: { $all: [query0, query1] }}, function (err, p) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(p.id, post.id);\n          done();\n        });\n      });\n    });\n\n    it('using #or with nested #elemMatch', function(done){\n      var db = start()\n        , P = db.model('BlogPostB', collection);\n\n      var post = new P({ title: \"nested elemMatch\" });\n      post.comments.push({ title: 'comment D' }, { title: 'comment E' }, { title: 'comment F' })\n\n      var id0 = post.comments[0]._id;\n      var id1 = post.comments[1]._id;\n      var id2 = post.comments[2]._id;\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var query0 = { comments: { $elemMatch: { title: 'comment Z' }}};\n        var query1 = { comments: { $elemMatch: { _id: id1.toString(), title: 'comment E' }}};\n\n        P.findOne({ $or: [query0, query1] }, function (err, p) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(p.id, post.id);\n          done();\n        });\n      });\n    });\n\n    it('buffer $in array', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({sigs: [new Buffer([1, 2, 3]),\n                               new Buffer([4, 5, 6]),\n                               new Buffer([7, 8, 9])]}, function (err, created) {\n        assert.ifError(err);\n        BlogPostB.findOne({sigs: new Buffer([1, 2, 3])}, function (err, found) {\n          assert.ifError(err);\n          found.id;\n          assert.equal(found._id.toString(), created._id);\n          var query = { sigs: { \"$in\" : [new Buffer([3, 3, 3]), new Buffer([4, 5, 6])] } };\n          BlogPostB.findOne(query, function (err, found) {\n            assert.ifError(err);\n            db.close();\n            done();\n          });\n        });\n      });\n    });\n\n    it('regex with Array (gh-599)', function(done){\n      var db = start()\n        , B = db.model('BlogPostB', random())\n\n      B.create({ tags: 'wooof baaaark meeeeow'.split(' ') }, function (err, b) {\n        assert.ifError(err);\n        B.findOne({ tags: /ooof$/ }, function (err, doc) {\n          assert.ifError(err);\n          assert.strictEqual(true, !! doc);\n          assert.ok(!! ~doc.tags.indexOf('meeeeow'));\n\n          B.findOne({ tags: {$regex: 'eow$' } }, function (err, doc) {\n            db.close();\n            assert.ifError(err);\n            assert.strictEqual(true, !! doc);\n            assert.strictEqual(true, !! ~doc.tags.indexOf('meeeeow'));\n            done();\n          });\n        });\n      });\n    });\n\n    it('regex with options', function(done){\n      var db = start()\n        , B = db.model('BlogPostB', collection)\n\n      var post = new B({ title: '$option queries' });\n      post.save(function (err) {\n        assert.ifError(err);\n        B.findOne({ title: { $regex: ' QUERIES$', $options: 'i' }}, function (err, doc) {\n          db.close();\n          assert.strictEqual(null, err, err && err.stack);\n          assert.equal(doc.id, post.id);\n          done();\n        })\n      });\n    });\n\n    it('works with $elemMatch and $in combo (gh-1100)', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , id1 = new DocumentObjectId\n        , id2 = new DocumentObjectId\n\n      BlogPostB.create({owners: [id1, id2]}, function (err, created) {\n        assert.ifError(err);\n        BlogPostB.findOne({owners: {'$elemMatch': { $in: [id2.toString()] }}}, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.ok(found);\n          assert.equal(created.id, found.id);\n          done();\n        });\n      });\n    })\n  });\n\n  describe('findById', function () {\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , title = 'Edwald ' + random();\n\n      var post = new BlogPostB();\n      post.set('title', title);\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var pending = 2;\n\n        BlogPostB.findById(post.get('_id'), function (err, doc) {\n          assert.ifError(err);\n          assert.ok(doc instanceof BlogPostB);\n          assert.equal(title, doc.get('title'));\n          if (--pending) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.findById(post.get('_id').toHexString(), function (err, doc) {\n          assert.ifError(err);\n          assert.ok(doc instanceof BlogPostB);\n          assert.equal(title, doc.get('title'));\n          if (--pending) return;\n          db.close();\n          done();\n        });\n      });\n    });\n\n    it('works with partial initialization', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , queries = 5;\n\n      var post = new BlogPostB();\n\n      post.title = 'hahaha';\n      post.slug = 'woot';\n      post.meta.visitors = 53;\n      post.tags = ['humidity', 'soggy'];\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.findById(post.get('_id'), function (err, doc) {\n          assert.ifError(err);\n\n          assert.equal(true, doc.isInit('title'));\n          assert.equal(true, doc.isInit('slug'));\n          assert.equal(false, doc.isInit('date'));\n          assert.equal(true, doc.isInit('meta.visitors'));\n          assert.equal(53, doc.meta.visitors.valueOf());\n          assert.equal(2, doc.tags.length);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.findById(post.get('_id'), 'title', function (err, doc) {\n          assert.ifError(err);\n          assert.equal(true, doc.isInit('title'));\n          assert.equal(false, doc.isInit('slug'));\n          assert.equal(false, doc.isInit('date'));\n          assert.equal(false, doc.isInit('meta.visitors'));\n          assert.equal(undefined, doc.meta.visitors);\n          assert.equal(undefined, doc.tags);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.findById(post.get('_id'), '-slug', function (err, doc) {\n          assert.ifError(err);\n          assert.equal(true, doc.isInit('title'));\n          assert.equal(false, doc.isInit('slug'));\n          assert.equal(false, doc.isInit('date'));\n          assert.equal(true, doc.isInit('meta.visitors'));\n          assert.equal(53, doc.meta.visitors);\n          assert.equal(2, doc.tags.length);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.findById(post.get('_id'), { title:1 }, function (err, doc) {\n          assert.ifError(err);\n          assert.equal(true, doc.isInit('title'));\n          assert.equal(false, doc.isInit('slug'));\n          assert.equal(false, doc.isInit('date'));\n          assert.equal(false, doc.isInit('meta.visitors'));\n          assert.equal(undefined, doc.meta.visitors);\n          assert.equal(undefined, doc.tags);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.findById(post.get('_id'), 'slug', function (err, doc) {\n          assert.ifError(err);\n          assert.equal(false, doc.isInit('title'));\n          assert.equal(true, doc.isInit('slug'));\n          assert.equal(false, doc.isInit('date'));\n          assert.equal(false, doc.isInit('meta.visitors'));\n          assert.equal(undefined, doc.meta.visitors);\n          assert.equal(undefined, doc.tags);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n      });\n    });\n\n    it('querying if an array contains at least a certain single member (gh-220)', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      var post = new BlogPostB();\n\n      post.tags.push('cat');\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.findOne({tags: 'cat'}, function (err, doc) {\n          assert.ifError(err);\n          assert.equal(doc._id.toString(),post._id);\n          db.close();\n          done();\n        });\n      });\n    });\n\n\n    it('where an array where the $slice operator', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({numbers: [500,600,700,800]}, function (err, created) {\n        assert.ifError(err);\n        BlogPostB.findById(created._id, {numbers: {$slice: 2}}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(found._id.toString(), created._id);\n          assert.equal(2, found.numbers.length);\n          assert.equal(500, found.numbers[0]);\n          assert.equal(600, found.numbers[1]);\n          BlogPostB.findById(created._id, {numbers: {$slice: -2}}, function (err, found) {\n            assert.ifError(err);\n            assert.equal(found._id.toString(), created._id);\n            assert.equal(2, found.numbers.length);\n            assert.equal(700, found.numbers[0]);\n            assert.equal(800, found.numbers[1]);\n            BlogPostB.findById(created._id, {numbers: {$slice: [1, 2]}}, function (err, found) {\n              assert.ifError(err);\n              assert.equal(found._id.toString(), created._id);\n              assert.equal(2, found.numbers.length);\n              assert.equal(600, found.numbers[0]);\n              assert.equal(700, found.numbers[1]);\n              db.close();\n              done();\n            });\n          });\n        });\n      });\n    });\n\n  });\n\n  describe('find', function () {\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , title = 'Wooooot ' + random();\n\n      var post = new BlogPostB();\n      post.set('title', title);\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        var post = new BlogPostB();\n        post.set('title', title);\n\n        post.save(function (err) {\n          assert.ifError(err);\n\n          BlogPostB.find({ title: title }, function (err, docs) {\n            assert.ifError(err);\n            assert.equal(2, docs.length);\n\n            assert.equal(title, docs[0].get('title'));\n            assert.equal(false, docs[0].isNew);\n\n            assert.equal(title, docs[1].get('title'));\n            assert.equal(false, docs[1].isNew);\n\n            db.close();\n            done();\n          });\n        });\n      });\n    });\n\n    it('returns docs where an array that contains one specific member', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n      BlogPostB.create({numbers: [100, 101, 102]}, function (err, created) {\n        assert.ifError(err);\n        BlogPostB.find({numbers: 100}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(1, found.length);\n          assert.equal(found[0]._id.toString(), created._id);\n          db.close();\n          done();\n        });\n      });\n    });\n\n    it('works when comparing $ne with single value against an array', function(done){\n      var db = start();\n      var schema = new Schema({\n          ids: [Schema.ObjectId]\n        , b: Schema.ObjectId\n      });\n\n      var NE = db.model('NE_Test', schema, 'nes__' + random());\n\n      var id1 = new DocumentObjectId;\n      var id2 = new DocumentObjectId;\n      var id3 = new DocumentObjectId;\n      var id4 = new DocumentObjectId;\n\n      NE.create({ ids: [id1, id4], b: id3 }, function (err, ne1) {\n        assert.ifError(err);\n        NE.create({ ids: [id2, id4], b: id3 },function (err, ne2) {\n          assert.ifError(err);\n\n          var query = NE.find({ 'b': id3.toString(), 'ids': { $ne: id1 }});\n          query.exec(function (err, nes1) {\n            assert.ifError(err);\n            assert.equal(1, nes1.length);\n\n            NE.find({ b: { $ne: [1] }}, function (err, nes2) {\n              assert.equal(\"Invalid ObjectId\", err.message);\n\n              NE.find({ b: { $ne: 4 }}, function (err, nes3) {\n                assert.equal(\"Invalid ObjectId\", err.message);\n\n                NE.find({ b: id3, ids: { $ne: id4 }}, function (err, nes4) {\n                  db.close();\n                  assert.ifError(err);\n                  assert.equal(0, nes4.length);\n                  done();\n                });\n              });\n            });\n          });\n\n        });\n      });\n    });\n\n    it('with partial initialization', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , queries = 4;\n\n      var post = new BlogPostB();\n\n      post.title = 'hahaha';\n      post.slug = 'woot';\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.find({ _id: post.get('_id') }, function (err, docs) {\n          assert.ifError(err);\n          assert.equal(true, docs[0].isInit('title'));\n          assert.equal(true, docs[0].isInit('slug'));\n          assert.equal(false, docs[0].isInit('date'));\n          assert.strictEqual('kandinsky', docs[0].def);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.find({ _id: post.get('_id') }, 'title', function (err, docs) {\n          assert.ifError(err);\n          assert.equal(true, docs[0].isInit('title'));\n          assert.equal(false, docs[0].isInit('slug'));\n          assert.equal(false, docs[0].isInit('date'));\n          assert.strictEqual(undefined, docs[0].def);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.find({ _id: post.get('_id') }, { slug: 0, def: 0 }, function (err, docs) {\n          assert.ifError(err);\n          assert.equal(true, docs[0].isInit('title'));\n          assert.equal(false, docs[0].isInit('slug'));\n          assert.equal(false, docs[0].isInit('date'));\n          assert.strictEqual(undefined, docs[0].def);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n\n        BlogPostB.find({ _id: post.get('_id') }, 'slug', function (err, docs) {\n          assert.ifError(err);\n          assert.equal(false, docs[0].isInit('title'));\n          assert.equal(true, docs[0].isInit('slug'));\n          assert.equal(false, docs[0].isInit('date'));\n          assert.strictEqual(undefined, docs[0].def);\n          if (--queries) return;\n          db.close();\n          done();\n        });\n      })\n    })\n\n    it('where $exists', function(done){\n      var db = start()\n        , ExistsSchema = new Schema({\n              a: Number\n            , b: String\n          });\n      mongoose.model('Exists', ExistsSchema);\n      var Exists = db.model('Exists', 'exists_' + random());\n      Exists.create({ a: 1}, function (err, aExisting) {\n        assert.ifError(err);\n        Exists.create({b: 'hi'}, function (err, bExisting) {\n          assert.ifError(err);\n          Exists.find({b: {$exists: true}}, function (err, docs) {\n            assert.ifError(err);\n            db.close();\n            assert.equal(1, docs.length);\n            done();\n          });\n        });\n      });\n    });\n\n    it('works with $elemMatch (gh-1100)', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection)\n        , id1 = new DocumentObjectId\n        , id2 = new DocumentObjectId\n\n      BlogPostB.create({owners: [id1, id2]}, function (err, createdAfter) {\n        assert.ifError(err);\n        BlogPostB.find({owners: {'$elemMatch': { $in: [id2.toString()] }}}, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(1, found.length);\n          done();\n        });\n      });\n    })\n\n    it('where $mod', function(done){\n      var db = start()\n        , Mod = db.model('Mod', 'mods_' + random());\n      Mod.create({num: 1}, function (err, one) {\n        assert.ifError(err);\n        Mod.create({num: 2}, function (err, two) {\n          assert.ifError(err);\n          Mod.find({num: {$mod: [2, 1]}}, function (err, found) {\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(), one._id);\n            db.close();\n            done();\n          });\n        });\n      });\n    });\n\n    it('where $not', function(done){\n      var db = start()\n        , Mod = db.model('Mod', 'mods_' + random());\n      Mod.create({num: 1}, function (err, one) {\n        assert.ifError(err);\n        Mod.create({num: 2}, function (err, two) {\n          assert.ifError(err);\n          Mod.find({num: {$not: {$mod: [2, 1]}}}, function (err, found) {\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(),two._id);\n            db.close();\n            done();\n          });\n        });\n      });\n    });\n\n    it('where or()', function(done){\n      var db = start()\n        , Mod = db.model('Mod', 'mods_' + random());\n\n      Mod.create({num: 1}, {num: 2, str: 'two'}, function (err, one, two) {\n        assert.ifError(err);\n\n        var pending = 3;\n        test1();\n        test2();\n        test3();\n\n        function test1 () {\n          Mod.find({$or: [{num: 1}, {num: 2}]}, function (err, found) {\n            cb();\n            assert.ifError(err);\n            assert.equal(2, found.length);\n            assert.equal(found[0]._id.toString(), one._id);\n            assert.equal(found[1]._id.toString(), two._id);\n          });\n        }\n\n        function test2 () {\n          Mod.find({ $or: [{ str: 'two'}, {str:'three'}] }, function (err, found) {\n            cb();\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(),two._id);\n          });\n        }\n\n        function test3 () {\n          Mod.find({$or: [{num: 1}]}).or([{ str: 'two' }]).exec(function (err, found) {\n            cb();\n            assert.ifError(err);\n            assert.equal(2, found.length);\n            assert.equal(found[0]._id.toString(), one._id);\n            assert.equal(found[1]._id.toString(), two._id);\n          });\n        }\n\n        function cb () {\n          if (--pending) return;\n          db.close();\n          done();\n        }\n      });\n    })\n\n    it('where $ne', function(done){\n      var db = start()\n        , Mod = db.model('Mod', 'mods_' + random());\n      Mod.create({num: 1}, function (err, one) {\n        assert.ifError(err);\n        Mod.create({num: 2}, function (err, two) {\n          assert.ifError(err);\n          Mod.create({num: 3}, function (err, three) {\n            assert.ifError(err);\n            Mod.find({num: {$ne: 1}}, function (err, found) {\n              assert.ifError(err);\n\n              assert.equal(found.length, 2);\n              assert.equal(found[0]._id.toString(),two._id);\n              assert.equal(found[1]._id.toString(),three._id);\n              db.close();\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('where $nor', function(done){\n      var db = start()\n        , Mod = db.model('Mod', 'nor_' + random());\n\n      Mod.create({num: 1}, {num: 2, str: 'two'}, function (err, one, two) {\n        assert.ifError(err);\n\n        var pending = 3;\n        test1();\n        test2();\n        test3();\n\n        function test1 () {\n          Mod.find({$nor: [{num: 1}, {num: 3}]}, function (err, found) {\n            cb();\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(),two._id);\n          });\n        }\n\n        function test2 () {\n          Mod.find({ $nor: [{ str: 'two'}, {str:'three'}] }, function (err, found) {\n            cb();\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(), one._id);\n          });\n        }\n\n        function test3 () {\n          Mod.find({$nor: [{num: 2}]}).nor([{ str: 'two' }]).exec(function (err, found) {\n            cb();\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(), one._id);\n          });\n        }\n\n        function cb () {\n          if (--pending) return;\n          db.close();\n          done()\n        }\n      });\n    });\n\n    it('STRICT null matches', function(done){\n      var db = start()\n      var BlogPostB = db.model('BlogPostB', collection + random());\n\n      var a = { title: 'A', author: null};\n      var b = { title: 'B' };\n      BlogPostB.create(a, b, function (err, createdA, createdB) {\n        assert.ifError(err);\n        BlogPostB.find({author: {$in: [null], $exists: true}}, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(1, found.length);\n          assert.equal(found[0]._id.toString(), createdA._id);\n          done();\n        });\n      });\n    });\n\n    it('null matches null and undefined', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection + random());\n\n      BlogPostB.create(\n          { title: 'A', author: null }\n        , { title: 'B' }, function (err, createdA, createdB) {\n        assert.ifError(err);\n        BlogPostB.find({author: null}, function (err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(2, found.length);\n          done();\n        });\n      });\n    });\n\n    it('a document whose arrays contain at least $all string values', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      var post = new BlogPostB({ title: \"Aristocats\" });\n\n      post.tags.push('onex');\n      post.tags.push('twox');\n      post.tags.push('threex');\n\n      post.save(function (err) {\n        assert.ifError(err);\n\n        BlogPostB.findById(post._id, function (err, post) {\n          assert.ifError(err);\n\n          BlogPostB.find({ title: { '$all': ['Aristocats']}}, function (err, docs) {\n            assert.ifError(err);\n            assert.equal(1, docs.length);\n\n            BlogPostB.find({ title: { '$all': [/^Aristocats/]}}, function (err, docs) {\n              assert.ifError(err);\n              assert.equal(1, docs.length);\n\n              BlogPostB.find({tags: { '$all': ['onex','twox','threex']}}, function (err, docs) {\n                assert.ifError(err);\n                assert.equal(1, docs.length);\n\n                BlogPostB.find({tags: { '$all': [/^onex/i]}}, function (err, docs) {\n                  assert.ifError(err);\n                  assert.equal(1, docs.length);\n\n                  BlogPostB.findOne({tags: { '$all': /^two/ }}, function (err, doc) {\n                    db.close();\n                    assert.ifError(err);\n                    assert.equal(post.id, doc.id);\n                    done();\n                  });\n                });\n              });\n            });\n          });\n        });\n\n      });\n    });\n\n    it('using #nor with nested #elemMatch', function(done){\n      var db = start()\n        , P = db.model('BlogPostB', collection + '_norWithNestedElemMatch');\n\n      var p0 = { title: \"nested $nor elemMatch1\", comments: [] };\n\n      var p1 = { title: \"nested $nor elemMatch0\", comments: [] };\n      p1.comments.push({ title: 'comment X' }, { title: 'comment Y' }, { title: 'comment W' })\n\n      P.create(p0, p1, function (err, post0, post1) {\n        assert.ifError(err);\n\n        var id = post1.comments[1]._id;\n\n        var query0 = { comments: { $elemMatch: { title: 'comment Z' }}};\n        var query1 = { comments: { $elemMatch: { _id: id.toString(), title: 'comment Y' }}};\n\n        P.find({ $nor: [query0, query1] }, function (err, posts) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(1, posts.length);\n          assert.equal(posts[0].id, post0.id);\n          done();\n        });\n      });\n    });\n\n    it('strings via regexp', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({title: 'Next to Normal'}, function (err, created) {\n        assert.ifError(err);\n        BlogPostB.findOne({title: /^Next/}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(found._id.toString(), created._id);\n\n          var reg = '^Next to Normal$';\n\n          BlogPostB.find({ title: { $regex: reg }}, function (err, found) {\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(), created._id);\n\n            BlogPostB.findOne({ title: { $regex: reg }}, function (err, found) {\n              assert.ifError(err);\n              assert.equal(found._id.toString(), created._id);\n\n              BlogPostB.where('title').regex(reg).findOne(function (err, found) {\n                assert.ifError(err);\n                assert.equal(found._id.toString(), created._id);\n\n                BlogPostB.where('title').regex(/^Next/).findOne(function (err, found) {\n                  db.close();\n                  assert.ifError(err);\n                  assert.equal(found._id.toString(), created._id);\n                  done();\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n\n    it('a document whose arrays contain at least $all values', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n      var a1 = {numbers: [-1,-2,-3,-4], meta: { visitors: 4 }};\n      var a2 = {numbers: [0,-1,-2,-3,-4]};\n      BlogPostB.create(a1, a2, function (err, whereoutZero, whereZero) {\n        assert.ifError(err);\n\n        BlogPostB.find({numbers: {$all: [-1, -2, -3, -4]}}, function (err, found) {\n          assert.ifError(err);\n          assert.equal(2, found.length);\n          BlogPostB.find({'meta.visitors': {$all: [4] }}, function (err, found) {\n            assert.ifError(err);\n            assert.equal(1, found.length);\n            assert.equal(found[0]._id.toString(), whereoutZero._id);\n            BlogPostB.find({numbers: {$all: [0, -1]}}, function (err, found) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(1, found.length);\n              assert.equal(found[0]._id.toString(), whereZero._id);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('where $size', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({numbers: [1,2,3,4,5,6,7,8,9,10]}, function (err, whereoutZero) {\n        assert.ifError(err);\n        BlogPostB.create({numbers: [11,12,13,14,15,16,17,18,19,20]}, function (err, whereZero) {\n          assert.ifError(err);\n          BlogPostB.create({numbers: [1,2,3,4,5,6,7,8,9,10,11]}, function (err, found) {\n            assert.ifError(err);\n            BlogPostB.find({numbers: {$size: 10}}, function (err, found) {\n              assert.ifError(err);\n              assert.equal(2, found.length);\n              BlogPostB.find({numbers: {$size: 11}}, function (err, found) {\n                assert.ifError(err);\n                assert.equal(1, found.length);\n                db.close();\n                done();\n              });\n            });\n          });\n        });\n      });\n    });\n\n    it('$gt, $lt, $lte, $gte work on strings', function(done){\n      var db = start()\n      var D = db.model('D', new Schema({dt: String}), collection);\n\n      D.create({ dt: '2011-03-30' }, cb);\n      D.create({ dt: '2011-03-31' }, cb);\n      D.create({ dt: '2011-04-01' }, cb);\n      D.create({ dt: '2011-04-02' }, cb);\n\n      var pending = 4;\n      function cb (err) {\n        if (err) db.close();\n        assert.ifError(err);\n\n        if (--pending) return;\n\n        pending = 2;\n\n        D.find({ 'dt': { $gte: '2011-03-30', $lte: '2011-04-01' }}).sort('dt').exec(function (err, docs) {\n          if (!--pending) {\n            db.close();\n            done();\n          }\n          assert.ifError(err);\n          assert.equal(3, docs.length);\n          assert.equal(docs[0].dt, '2011-03-30');\n          assert.equal(docs[1].dt, '2011-03-31');\n          assert.equal(docs[2].dt, '2011-04-01');\n          assert.equal(false, docs.some(function (d) { return '2011-04-02' === d.dt }));\n        });\n\n        D.find({ 'dt': { $gt: '2011-03-30', $lt: '2011-04-02' }}).sort('dt').exec(function (err, docs) {\n          if (!--pending) {\n            db.close();\n            done();\n          }\n          assert.ifError(err);\n          assert.equal(2, docs.length);\n          assert.equal(docs[0].dt, '2011-03-31');\n          assert.equal(docs[1].dt, '2011-04-01');\n          assert.equal(false, docs.some(function (d) { return '2011-03-30' === d.dt }));\n          assert.equal(false, docs.some(function (d) { return '2011-04-02' === d.dt }));\n        });\n      }\n\n    })\n  });\n\n  describe('limit', function(){\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({title: 'first limit'}, function (err, first) {\n        assert.ifError(err);\n        BlogPostB.create({title: 'second limit'}, function (err, second) {\n          assert.ifError(err);\n          BlogPostB.create({title: 'third limit'}, function (err, third) {\n            assert.ifError(err);\n            BlogPostB.find({title: /limit$/}).limit(2).find( function (err, found) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(2, found.length);\n              assert.equal(found[0].id, first.id);\n              assert.equal(found[1].id, second.id);\n              done()\n            });\n          });\n        });\n      });\n    })\n  })\n\n  describe('skip', function(){\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({title: 'first skip'}, function (err, first) {\n        assert.ifError(err);\n        BlogPostB.create({title: 'second skip'}, function (err, second) {\n          assert.ifError(err);\n          BlogPostB.create({title: 'third skip'}, function (err, third) {\n            assert.ifError(err);\n            BlogPostB.find({title: /skip$/}).skip(1).limit(2).find( function (err, found) {\n              assert.ifError(err);\n              assert.equal(2,found.length);\n              assert.equal(found[0].id,second._id);\n              assert.equal(found[1].id,third._id);\n              db.close();\n              done();\n            });\n          });\n        });\n      });\n    })\n  });\n\n  describe('sort', function(){\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.create({meta: {visitors: 100}}, function (err, least) {\n        assert.ifError(err);\n        BlogPostB.create({meta: {visitors: 300}}, function (err, largest) {\n          assert.ifError(err);\n          BlogPostB.create({meta: {visitors: 200}}, function (err, middle) {\n            assert.ifError(err);\n            BlogPostB\n            .where('meta.visitors').gt(99).lt(301)\n            .sort('-meta.visitors')\n            .find( function (err, found) {\n              assert.ifError(err);\n              assert.equal(3, found.length);\n              assert.equal(found[0].id, largest._id);\n              assert.equal(found[1].id, middle._id);\n              assert.equal(found[2].id, least._id);\n              db.close();\n              done();\n            });\n          });\n        });\n      });\n    })\n  });\n\n  describe('nested mixed \"x.y.z\"', function(){\n    it('works', function(done){\n      var db = start()\n        , BlogPostB = db.model('BlogPostB', collection);\n\n      BlogPostB.find({ 'mixed.nested.stuff': 'skynet' }, function (err, docs) {\n        db.close();\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n  it('by Date (gh-336)', function(done){\n    // GH-336\n    var db = start()\n      , Test = db.model('TestDateQuery', new Schema({ date: Date }), 'datetest_' + random())\n      , now = new Date;\n\n    Test.create({ date: now }, { date: new Date(now-10000) }, function (err, a, b) {\n      assert.ifError(err);\n      Test.find({ date: now }, function (err, docs) {\n        db.close();\n        assert.ifError(err);\n        assert.equal(1, docs.length);\n        done();\n      });\n    });\n  })\n\n  it('mixed types with $elemMatch (gh-591)', function(done){\n    var db = start()\n      , S = new Schema({ a: [{}], b: Number })\n      , M = db.model('QueryingMixedArrays', S, random())\n\n    var m = new M;\n    m.a = [1,2,{ name: 'Frodo' },'IDK', {name: 100}];\n    m.b = 10;\n\n    m.save(function (err) {\n      assert.ifError(err);\n\n      M.find({ a: { name: 'Frodo' }, b: '10' }, function (err, docs) {\n        assert.ifError(err);\n        assert.equal(5, docs[0].a.length);\n        assert.equal(10, docs[0].b.valueOf());\n\n        var query = {\n            a: {\n                $elemMatch: { name: 100 }\n            }\n        }\n\n        M.find(query, function (err, docs) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(5, docs[0].a.length);\n          done();\n        });\n      });\n    });\n  });\n\n  describe('$all', function(){\n    it('with ObjectIds (gh-690)', function (done) {\n      var db = start()\n\n      var SSchema = new Schema({ name: String });\n      var PSchema = new Schema({ sub: [SSchema] });\n\n      var P = db.model('usingAllWithObjectIds', PSchema);\n      var sub = [{ name: 'one' }, { name: 'two' }, { name: 'three' }];\n\n      P.create({ sub: sub }, function (err, p) {\n        assert.ifError(err);\n\n        var o0 = p.sub[0]._id;\n        var o1 = p.sub[1]._id;\n        var o2 = p.sub[2]._id;\n\n        P.findOne({ 'sub._id': { $all: [o1, o2] }}, function (err, doc) {\n          assert.ifError(err);\n          assert.equal(doc.id, p.id);\n\n          P.findOne({ 'sub._id': { $all: [o0, new DocumentObjectId] }}, function (err, doc) {\n            assert.ifError(err);\n            assert.equal(false, !!doc);\n\n            P.findOne({ 'sub._id': { $all: [o2] }}, function (err, doc) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(doc.id, p.id);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('with Dates', function(done){\n      this.timeout(3000);\n      // this.slow(2000);\n      var db = start()\n\n      var SSchema = new Schema({ d: Date });\n      var PSchema = new Schema({ sub: [SSchema] });\n\n      var P = db.model('usingAllWithDates', PSchema);\n      var sub = [\n          { d: new Date }\n        , { d: new Date(Date.now()-10000) }\n        , { d: new Date(Date.now()-30000) }\n      ];\n\n      P.create({ sub: sub }, function (err, p) {\n        assert.ifError(err);\n\n        var o0 = p.sub[0].d;\n        var o1 = p.sub[1].d;\n        var o2 = p.sub[2].d;\n\n        P.findOne({ 'sub.d': { $all: [o1, o2] }}, function (err, doc) {\n          assert.ifError(err);\n          assert.equal(doc.id,p.id);\n\n          P.findOne({ 'sub.d': { $all: [o0, new Date] }}, function (err, doc) {\n            assert.ifError(err);\n            assert.equal(false, !!doc);\n\n            P.findOne({ 'sub.d': { $all: [o2] }}, function (err, doc) {\n              db.close();\n              assert.ifError(err);\n              assert.equal(doc.id, p.id);\n              done();\n            });\n          });\n        });\n      });\n    });\n  });\n});\n\ndescribe('buffers', function(){\n  it('works with different methods and query types', function(done){\n    var db = start()\n      , BufSchema = new Schema({ name: String, block: Buffer })\n      , Test = db.model('Buffer', BufSchema, \"buffers\");\n\n    var docA = { name: 'A', block: new Buffer('über') };\n    var docB = { name: 'B', block: new Buffer(\"buffer shtuffs are neat\") };\n    var docC = { name: 'C', block: 'hello world' };\n\n    Test.create(docA, docB, docC, function (err, a, b, c) {\n      assert.ifError(err);\n      assert.equal(b.block.toString('utf8'),'buffer shtuffs are neat');\n      assert.equal(a.block.toString('utf8'),'über');\n      assert.equal(c.block.toString('utf8'),'hello world');\n\n      Test.findById(a._id, function (err, a) {\n        assert.ifError(err);\n        assert.equal(a.block.toString('utf8'),'über');\n\n        Test.findOne({ block: 'buffer shtuffs are neat' }, function (err, rb) {\n          assert.ifError(err);\n          assert.equal(rb.block.toString('utf8'),'buffer shtuffs are neat');\n\n          Test.findOne({ block: /buffer/i }, function (err, rb) {\n            assert.equal(err.message, 'Cast to buffer failed for value \"/buffer/i\"')\n            Test.findOne({ block: [195, 188, 98, 101, 114] }, function (err, rb) {\n              assert.ifError(err);\n              assert.equal(rb.block.toString('utf8'),'über');\n\n              Test.findOne({ block: 'aGVsbG8gd29ybGQ=' }, function (err, rb) {\n                assert.ifError(err);\n                assert.strictEqual(rb, null);\n\n                Test.findOne({ block: new Buffer('aGVsbG8gd29ybGQ=', 'base64') }, function (err, rb) {\n                  assert.ifError(err);\n                  assert.equal(rb.block.toString('utf8'),'hello world');\n\n                  Test.findOne({ block: new MongooseBuffer('aGVsbG8gd29ybGQ=', 'base64') }, function (err, rb) {\n                    assert.ifError(err);\n                    assert.equal(rb.block.toString('utf8'),'hello world');\n\n                    Test.remove({}, function (err) {\n                      db.close();\n                      assert.ifError(err);\n                      done();\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n\n    });\n  });\n\n  it('with conditionals', function(done){\n    // $in $nin etc\n    var db = start()\n      , BufSchema = new Schema({ name: String, block: Buffer })\n      , Test = db.model('Buffer2', BufSchema, \"buffer_\"+random());\n\n    var docA = { name: 'A', block: new MongooseBuffer([195, 188, 98, 101, 114]) }; //über\n    var docB = { name: 'B', block: new MongooseBuffer(\"buffer shtuffs are neat\") };\n    var docC = { name: 'C', block: new MongooseBuffer('aGVsbG8gd29ybGQ=', 'base64') };\n\n    Test.create(docA, docB, docC, function (err, a, b, c) {\n      assert.ifError(err);\n      assert.equal(a.block.toString('utf8'),'über');\n      assert.equal(b.block.toString('utf8'),'buffer shtuffs are neat');\n      assert.equal(c.block.toString('utf8'),'hello world')\n\n      Test.find({ block: { $in: [[195, 188, 98, 101, 114], \"buffer shtuffs are neat\", new Buffer('aGVsbG8gd29ybGQ=', 'base64')] }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(3, tests.length);\n      });\n\n      Test.find({ block: { $in: ['über', 'hello world'] }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(2, tests.length);\n      });\n\n      Test.find({ block: { $in: ['über'] }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(1, tests.length);\n        assert.equal(tests[0].block.toString('utf8'),'über');\n      });\n\n      Test.find({ block: { $nin: ['über'] }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(2, tests.length);\n      });\n\n      Test.find({ block: { $nin: [[195, 188, 98, 101, 114], new Buffer('aGVsbG8gd29ybGQ=', 'base64')] }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(1, tests.length);\n        assert.equal(tests[0].block.toString('utf8'),'buffer shtuffs are neat');\n      });\n\n      Test.find({ block: { $ne: 'über' }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(2, tests.length);\n      });\n\n      Test.find({ block: { $gt: 'über' }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(2, tests.length);\n      });\n\n      Test.find({ block: { $gte: 'über' }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(3, tests.length);\n      });\n\n      Test.find({ block: { $lt: new Buffer('buffer shtuffs are neat') }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(2, tests.length);\n        assert.equal(tests[0].block.toString('utf8'),'über');\n      });\n\n      Test.find({ block: { $lte: 'buffer shtuffs are neat' }}, function (err, tests) {\n        cb();\n        assert.ifError(err);\n        assert.equal(3, tests.length);\n      });\n\n      var pending = 9;\n      function cb () {\n        if (--pending) return;\n        Test.remove({}, function (err) {\n          db.close();\n          assert.ifError(err);\n          done();\n        });\n      }\n    });\n  });\n})\n\ndescribe('backwards compatibility', function(){\n  it('with previously existing null values in the db', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n      , post = new BlogPostB();\n\n    post.collection.insert({ meta: { visitors: 9898, a: null } }, {}, function (err, b) {\n      assert.ifError(err);\n\n      BlogPostB.findOne({_id: b[0]._id}, function (err, found) {\n        assert.ifError(err);\n        assert.equal(9898, found.get('meta.visitors').valueOf());\n        db.close();\n        done();\n      })\n    })\n  });\n\n  it('with unused values in the db', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n      , post = new BlogPostB();\n\n    post.collection.insert({ meta: { visitors: 9898, color: 'blue'}}, {}, function (err, b) {\n      assert.ifError(err);\n\n      BlogPostB.findOne({_id: b[0]._id}, function (err, found) {\n        assert.ifError(err);\n        assert.equal(9898, found.get('meta.visitors').valueOf());\n        found.save(function (err) {\n          assert.ifError(err);\n          db.close();\n          done();\n        })\n      })\n    })\n  });\n});\n\ndescribe('geo-spatial', function(){\n  it('$near (gh-309)', function(done){\n    var db = start()\n      , Test = db.model('Geo1', geoSchema, 'geospatial'+random());\n\n    Test.create({ loc: [ 10, 20 ]}, { loc: [ 40, 90 ]}, function (err) {\n      assert.ifError(err);\n      setTimeout(function () {\n        Test.find({ loc: { $near: [30, 40] }}, function (err, docs) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(2, docs.length);\n          done();\n        });\n      }, 100);\n    });\n  });\n\n  it('$within arrays (gh-586)', function(done){\n    var db = start()\n      , Test = db.model('Geo2', geoSchema, collection + 'geospatial');\n\n    Test.create({ loc: [ 35, 50 ]}, { loc: [ -40, -90 ]}, function (err) {\n      assert.ifError(err);\n      setTimeout(function () {\n        Test.find({ loc: { '$within': { '$box': [[30,40], [40,60]] }}}, function (err, docs) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(1, docs.length);\n          done()\n        });\n      }, 100);\n    });\n  });\n\n  it('$nearSphere with arrays (gh-610)', function(done){\n    var db = start()\n      , Test = db.model('Geo3', geoSchema, \"y\"+random());\n\n    Test.create({ loc: [ 10, 20 ]}, { loc: [ 40, 90 ]}, function (err) {\n      assert.ifError(err);\n      setTimeout(function () {\n        Test.find({ loc: { $nearSphere: [30, 40] }}, function (err, docs) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(2, docs.length);\n          done()\n        });\n      }, 100);\n    });\n  });\n\n  it('$maxDistance with arrays', function(done){\n    var db = start()\n      , Test = db.model('Geo4', geoSchema, \"x\"+random());\n\n    Test.create({ loc: [ 20, 80 ]}, { loc: [ 25, 30 ]}, function (err, docs) {\n      assert.ifError(err);\n      setTimeout(function () {\n        Test.find({ loc: { $near: [25, 31], $maxDistance: 1 }}, function (err, docs) {\n          assert.ifError(err);\n          assert.equal(1, docs.length);\n          Test.find({ loc: { $near: [25, 32], $maxDistance: 1 }}, function (err, docs) {\n            db.close();\n            assert.ifError(err);\n            assert.equal(0, docs.length);\n            done();\n          });\n        });\n      }, 100);\n    });\n  })\n});\n\ndescribe('lean option:', function(){\n   it('find', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n      , title = 'Wooooot ' + random();\n\n    var post = new BlogPostB();\n    post.set('title', title);\n\n    post.save(function (err) {\n      assert.ifError(err);\n      BlogPostB.find({title : title}).lean().exec(function(err, docs){\n        assert.ifError(err);\n        assert.equal(docs.length, 1);\n        assert.strictEqual(docs[0] instanceof mongoose.Document, false);\n        BlogPostB.find({title : title}, null, { lean : true }, function(err, docs){\n          assert.ifError(err);\n          assert.equal(docs.length, 1);\n          assert.strictEqual(docs[0] instanceof mongoose.Document, false);\n          db.close();\n          done();\n        });\n      });\n    });\n  });\n\n  it('findOne', function(done){\n    var db = start()\n      , BlogPostB = db.model('BlogPostB', collection)\n      , title = 'Wooooot ' + random();\n\n    var post = new BlogPostB();\n    post.set('title', title);\n\n    post.save(function (err) {\n      assert.ifError(err);\n      BlogPostB.findOne({title : title}, null, { lean : true }, function(err, doc){\n        db.close();\n        assert.ifError(err);\n        assert.ok(doc);\n        assert.strictEqual(false, doc instanceof mongoose.Document);\n        done();\n      });\n    });\n  });\n\n})\n"]],"start1":0,"start2":0,"length1":0,"length2":59760}]],"length":59760}
