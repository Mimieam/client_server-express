{"ts":1352899270020,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/**\n * Module dependencies.\n */\n\nvar start = require('./common')\n  , mongoose = start.mongoose\n  , assert = require('assert')\n  , Schema = mongoose.Schema\n  , Document = mongoose.Document\n  , SchemaType = mongoose.SchemaType\n  , VirtualType = mongoose.VirtualType\n  , ObjectId = Schema.ObjectId\n  , ValidatorError = SchemaType.ValidatorError\n  , CastError = SchemaType.CastError\n  , SchemaTypes = Schema.Types\n  , DocumentObjectId = mongoose.Types.ObjectId\n  , Mixed = SchemaTypes.Mixed\n  , MongooseArray = mongoose.Types.Array\n  , ReadPref = require('mongodb').ReadPreference\n  , vm = require('vm')\n\n/**\n * Test Document constructor.\n */\n\nfunction TestDocument () {\n  Document.apply(this, arguments);\n};\n\n/**\n * Inherits from Document.\n */\n\nTestDocument.prototype.__proto__ = Document.prototype;\n\n/**\n * Set a dummy schema to simulate compilation.\n */\n\nTestDocument.prototype._setSchema(new Schema({\n    test    : String\n}));\n\n/**\n * Test.\n */\n\ndescribe('schema', function(){\n  it('can be created without the \"new\" keyword', function(){\n    var schema = Schema({ name: String });\n    assert.ok(schema instanceof Schema);\n  })\n\n  it('supports different schematypes', function(){\n    var Checkin = new Schema({\n        date      : Date \n      , location  : {\n            lat: Number\n          , lng: Number\n        }\n    });\n\n    var Ferret = new Schema({\n        name      : String\n      , owner     : ObjectId\n      , fur       : String\n      , color     : { type: String }\n      , age       : Number\n      , checkins  : [Checkin]\n      , friends   : [ObjectId]\n      , likes     : Array\n      , alive     : Boolean\n      , extra     : Mixed\n    });\n\n    assert.ok(Ferret.path('name') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('owner') instanceof SchemaTypes.ObjectId);\n    assert.ok(Ferret.path('fur') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('color') instanceof SchemaTypes.String);\n    assert.ok(Ferret.path('age') instanceof SchemaTypes.Number);\n    assert.ok(Ferret.path('checkins') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Ferret.path('friends') instanceof SchemaTypes.Array);\n    assert.ok(Ferret.path('likes') instanceof SchemaTypes.Array);\n    assert.ok(Ferret.path('alive') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret.path('extra') instanceof SchemaTypes.Mixed);\n\n    assert.strictEqual(Ferret.path('unexistent'), undefined);\n\n    assert.ok(Checkin.path('date') instanceof SchemaTypes.Date);\n\n    // check strings\n    var Checkin1 = new Schema({\n        date      : 'date'\n      , location  : {\n            lat: 'number'\n          , lng: 'Number'\n        }\n    });\n\n    assert.ok(Checkin1.path('date') instanceof SchemaTypes.Date);\n    assert.ok(Checkin1.path('location.lat') instanceof SchemaTypes.Number);\n    assert.ok(Checkin1.path('location.lng') instanceof SchemaTypes.Number);\n\n    var Ferret1 = new Schema({\n        name      : \"string\"\n      , owner     : \"oid\"\n      , fur       : { type: \"string\" }\n      , color     : { type: \"String\" }\n      , checkins  : [Checkin]\n      , friends   : Array\n      , likes     : \"array\"\n      , alive     : \"Bool\"\n      , alive1    : \"bool\"\n      , alive2    : \"boolean\"\n      , extra     : \"mixed\"\n      , obj       : \"object\"\n      , buf       : \"buffer\"\n      , Buf       : \"Buffer\"\n    });\n\n    assert.ok(Ferret1.path('name') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('owner') instanceof SchemaTypes.ObjectId);\n    assert.ok(Ferret1.path('fur') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('color') instanceof SchemaTypes.String);\n    assert.ok(Ferret1.path('checkins') instanceof SchemaTypes.DocumentArray);\n    assert.ok( Ferret1.path('friends') instanceof SchemaTypes.Array);\n    assert.ok(Ferret1.path('likes') instanceof SchemaTypes.Array);\n    assert.ok(Ferret1.path('alive') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('alive1') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('alive2') instanceof SchemaTypes.Boolean);\n    assert.ok(Ferret1.path('extra') instanceof SchemaTypes.Mixed);\n    assert.ok(Ferret1.path('obj') instanceof SchemaTypes.Mixed);\n    assert.ok(Ferret1.path('buf') instanceof SchemaTypes.Buffer);\n    assert.ok(Ferret1.path('Buf') instanceof SchemaTypes.Buffer);\n  });\n\n  it('supports dot notation for path accessors', function(){\n    var Racoon = new Schema({\n        name  : { type: String, enum: ['Edwald', 'Tobi'] }\n      , age   : Number\n    });\n\n    var Person = new Schema({\n        name      : String\n      , raccoons  : [Racoon]\n      , location  : {\n            city  : String\n          , state : String\n        }\n    });\n\n    assert.ok(Person.path('name') instanceof SchemaTypes.String);\n    assert.ok(Person.path('raccoons') instanceof SchemaTypes.DocumentArray);\n    assert.ok(Person.path('location.city') instanceof SchemaTypes.String);\n    assert.ok(Person.path('location.state') instanceof SchemaTypes.String);\n\n    assert.strictEqual(Person.path('location.unexistent'), undefined);\n  })\n\n  it('allows paths nested > 2 levels', function(){\n    var Nested = new Schema({\n      first: {\n        second: {\n          third: String\n        }\n      }\n    });\n    assert.ok(Nested.path('first.second.third') instanceof SchemaTypes.String);\n  });\n\n  it('default definition', function(){\n    var Test = new Schema({\n        simple    : { type: String, default: 'a' }\n      , array     : { type: Array, default: [1,2,3,4,5] }\n      , arrayX    : { type: Array, default: 9 }\n      , arrayFn   : { type: Array, default: function () { return [8] } }\n      , callback  : { type: Number, default: function(){\n          assert.equal('b', this.a);\n          return '3';\n        }}\n    });\n\n    assert.equal(Test.path('simple').defaultValue, 'a');\n    assert.equal(typeof Test.path('callback').defaultValue, 'function');\n\n    assert.equal(Test.path('simple').getDefault(), 'a');\n    assert.equal((+Test.path('callback').getDefault({ a: 'b' })), 3);\n    assert.equal(typeof Test.path('array').defaultValue, 'function');\n    assert.equal(Test.path('array').getDefault(new TestDocument)[3], 4);\n    assert.equal(Test.path('arrayX').getDefault(new TestDocument)[0], 9);\n    assert.equal(typeof Test.path('arrayFn').defaultValue, 'function');\n    assert.ok(Test.path('arrayFn').getDefault(new TestDocument) instanceof MongooseArray);\n  })\n\n  it('Mixed defaults can be empty arrays', function(){\n    var Test = new Schema({\n        mixed1    : { type: Mixed, default: [] }\n      , mixed2    : { type: Mixed, default: Array }\n    });\n\n    assert.ok(Test.path('mixed1').getDefault() instanceof Array);\n    assert.equal(Test.path('mixed1').getDefault().length, 0);\n    assert.ok(Test.path('mixed2').getDefault() instanceof Array);\n    assert.equal(Test.path('mixed2').getDefault().length, 0);\n  })\n\n  describe('validation', function(){\n    it('invalid arguments are rejected (1044)', function(){\n      assert.throws(function () {\n        new Schema({\n            simple: { type: String, validate: 'nope' }\n        });\n      }, /Invalid validator/);\n\n      assert.throws(function () {\n        new Schema({\n            simple: { type: String, validate: ['nope'] }\n        });\n      }, /Invalid validator/);\n\n      assert.throws(function () {\n        new Schema({\n          simple: { type: String, validate: { nope: 1, msg: 'nope' } }\n        });\n      }, /Invalid validator/);\n\n      assert.throws(function () {\n        new Schema({\n          simple: { type: String, validate: [{ nope: 1, msg: 'nope' }, 'nope'] }\n        });\n      }, /Invalid validator/);\n    })\n\n    it('string required', function(){\n      var Test = new Schema({\n          simple: String\n      });\n\n      Test.path('simple').required(true);\n      assert.equal(Test.path('simple').validators.length, 1);\n\n      Test.path('simple').doValidate(null, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Test.path('simple').doValidate(undefined, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Test.path('simple').doValidate('', function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Test.path('simple').doValidate('woot', function(err){\n        assert.ifError(err);\n      });\n    });\n\n    it('string enum', function(){\n      var Test = new Schema({\n          complex: { type: String, enum: ['a', 'b', undefined, 'c', null] }\n      });\n\n      assert.ok(Test.path('complex') instanceof SchemaTypes.String);\n      assert.deepEqual(Test.path('complex').enumValues,['a', 'b', 'c', null]);\n      assert.equal(Test.path('complex').validators.length, 1)\n\n      Test.path('complex').enum('d', 'e');\n\n      assert.deepEqual(Test.path('complex').enumValues, ['a', 'b', 'c', null, 'd', 'e']);\n\n      Test.path('complex').doValidate('x', function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      // allow unsetting enums\n      Test.path('complex').doValidate(undefined, function(err){\n        assert.ifError(err);\n      });\n\n      Test.path('complex').doValidate(null, function(err){\n        assert.ifError(err);\n      });\n\n      Test.path('complex').doValidate('da', function(err){\n        assert.ok(err instanceof ValidatorError);\n      })\n    })\n\n    it('string regexp', function(){\n      var Test = new Schema({\n          simple: { type: String, match: /[a-z]/ }\n      });\n\n      assert.equal(1, Test.path('simple').validators.length);\n\n      Test.path('simple').doValidate('az', function(err){\n        assert.ifError(err);\n      });\n\n      Test.path('simple').match(/[0-9]/);\n      assert.equal(2, Test.path('simple').validators.length);\n\n      Test.path('simple').doValidate('12', function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Test.path('simple').doValidate('a12', function(err){\n        assert.ifError(err);\n      });\n\n      Test.path('simple').doValidate('', function(err){\n        assert.ifError(err);\n      });\n      Test.path('simple').doValidate(null, function(err){\n        assert.ifError(err);\n      });\n      Test.path('simple').doValidate(undefined, function(err){\n        assert.ifError(err);\n      });\n      Test.path('simple').validators = [];\n      Test.path('simple').match(/[1-9]/);\n      Test.path('simple').doValidate(0, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n    })\n\n    it('number min and max', function(){\n      var Tobi = new Schema({\n          friends: { type: Number, max: 15, min: 5 }\n      });\n\n      assert.equal(Tobi.path('friends').validators.length, 2);\n\n      Tobi.path('friends').doValidate(10, function(err){\n        assert.ifError(err);\n      });\n\n      Tobi.path('friends').doValidate(100, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Tobi.path('friends').doValidate(1, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      // null is allowed\n      Tobi.path('friends').doValidate(null, function(err){\n        assert.ifError(err);\n      });\n    });\n\n    it('number required', function(){\n      var Edwald = new Schema({\n          friends: { type: Number, required: true }\n      });\n\n      Edwald.path('friends').doValidate(null, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Edwald.path('friends').doValidate(undefined, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Edwald.path('friends').doValidate(0, function(err){\n        assert.ifError(err);\n      });\n    })\n\n    it('date required', function(){\n      var Loki = new Schema({\n          birth_date: { type: Date, required: true }\n      });\n\n      Loki.path('birth_date').doValidate(null, function (err) {\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Loki.path('birth_date').doValidate(undefined, function (err) {\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Loki.path('birth_date').doValidate(new Date(), function (err) {\n        assert.ifError(err);\n      });\n    });\n\n    it('objectid required', function(){\n      var Loki = new Schema({\n          owner: { type: ObjectId, required: true }\n      });\n\n      Loki.path('owner').doValidate(new DocumentObjectId(), function(err){\n        assert.ifError(err);\n      });\n\n      Loki.path('owner').doValidate(null, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Loki.path('owner').doValidate(undefined, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n    });\n\n    it('array required', function(){\n      var Loki = new Schema({\n          likes: { type: Array, required: true }\n      });\n\n      Loki.path('likes').doValidate(null, function (err) {\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Loki.path('likes').doValidate(undefined, function (err) {\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Loki.path('likes').doValidate([], function (err) {\n        assert.ok(err instanceof ValidatorError);\n      });\n    });\n\n    it('boolean required', function(){\n      var Animal = new Schema({\n          isFerret: { type: Boolean, required: true }\n      });\n\n      Animal.path('isFerret').doValidate(null, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Animal.path('isFerret').doValidate(undefined, function(err){\n        assert.ok(err instanceof ValidatorError);\n      });\n\n      Animal.path('isFerret').doValidate(true, function(err){\n        assert.ifError(err);\n      });\n\n      Animal.path('isFerret').doValidate(false, function(err){\n        assert.ifError(err);\n      });\n    });\n\n    describe('async', function(){\n      it('works', function(done){\n        var executed = 0;\n\n        function validator (value, fn) {\n          setTimeout(function(){\n            executed++;\n            fn(value === true);\n            if (2 === executed) done();\n          }, 5);\n        };\n\n        var Animal = new Schema({\n            ferret: { type: Boolean, validate: validator }\n        });\n\n        Animal.path('ferret').doValidate(true, function(err){\n          assert.ifError(err);\n        });\n\n        Animal.path('ferret').doValidate(false, function(err){\n          assert.ok(err instanceof Error);\n        });\n      });\n\n      it('multiple', function(done) {\n        var executed = 0;\n\n        function validator (value, fn) {\n          setTimeout(function(){\n            executed++;\n            fn(value === true);\n            if (2 === executed) done();\n          }, 5);\n        };\n\n        var Animal = new Schema({\n          ferret: {\n            type: Boolean,\n            validate: [\n              {\n                'validator': validator,\n                'msg': 'validator1'\n              },\n              {\n                'validator': validator,\n                'msg': 'validator2'\n              },\n            ],\n          }\n        });\n\n        Animal.path('ferret').doValidate(true, function(err){\n          assert.ifError(err);\n        });\n      });\n\n      it('scope', function(done){\n        var called = false;\n        function validator (value, fn) {\n          assert.equal('b', this.a);\n\n          setTimeout(function(){\n            called = true;\n            fn(true);\n          }, 5);\n        };\n\n        var Animal = new Schema({\n            ferret: { type: Boolean, validate: validator }\n        });\n\n        Animal.path('ferret').doValidate(true, function(err){\n          assert.ifError(err);\n          assert.equal(true, called);\n          done();\n        }, { a: 'b' });\n      })\n    })\n  });\n\n  describe('casting', function(){\n    it('number', function(){\n      var Tobi = new Schema({\n          age: Number\n      });\n\n      // test String -> Number cast\n      assert.equal('number', typeof Tobi.path('age').cast('0'));\n      assert.equal(0, (+Tobi.path('age').cast('0')));\n\n      assert.equal('number', typeof Tobi.path('age').cast(0));\n      assert.equal(0, (+Tobi.path('age').cast(0)));\n    });\n\n    describe('string', function(){\n      it('works', function(){\n        var Tobi = new Schema({\n            nickname: String\n        });\n\n        function Test(){};\n        Test.prototype.toString = function(){\n          return 'woot';\n        };\n\n        // test Number -> String cast\n        assert.equal('string', typeof Tobi.path('nickname').cast(0));\n        assert.equal('0', Tobi.path('nickname').cast(0));\n\n        // test any object that implements toString\n        assert.equal('string', typeof Tobi.path('nickname').cast(new Test));\n        assert.equal('woot', Tobi.path('nickname').cast(new Test));\n      });\n      it('casts undefined to \"undefined\"', function(done){\n        var db= require('./common')();\n        var schema = new Schema({ arr: [String] });\n        var M = db.model('castingStringArrayWithUndefined', schema);\n        M.find({ arr: { $in: [undefined] }}, function (err) {\n          db.close();\n          assert.equal(err && err.message, 'Cast to string failed for value \"undefined\"');\n          done();\n        });\n      });\n    });\n\n    it('date', function(){\n      var Loki = new Schema({\n          birth_date: { type: Date }\n      });\n\n      assert.ok(Loki.path('birth_date').cast(1294525628301) instanceof Date);\n      assert.ok(Loki.path('birth_date').cast('8/24/2000') instanceof Date);\n      assert.ok(Loki.path('birth_date').cast(new Date) instanceof Date);\n    });\n\n    it('objectid', function(){\n      var Loki = new Schema({\n          owner: { type: ObjectId }\n      });\n\n      var doc = new TestDocument()\n        , id = doc._id.toString();\n\n      assert.ok(Loki.path('owner').cast('4c54f3453e688c000000001a')\n                        instanceof DocumentObjectId);\n\n      assert.ok(Loki.path('owner').cast(new DocumentObjectId())\n                        instanceof DocumentObjectId);\n\n      assert.ok(Loki.path('owner').cast(doc)\n                        instanceof DocumentObjectId);\n\n      assert.equal(id, Loki.path('owner').cast(doc).toString());\n    });\n\n    it('array', function(){\n      var Loki = new Schema({\n          oids        : [ObjectId]\n        , dates       : [Date]\n        , numbers     : [Number]\n        , strings     : [String]\n        , buffers     : [Buffer]\n        , nocast      : []\n        , mixed       : [Mixed]\n      });\n\n      var oids = Loki.path('oids').cast(['4c54f3453e688c000000001a', new DocumentObjectId]);\n\n      assert.ok(oids[0] instanceof DocumentObjectId);\n      assert.ok(oids[1] instanceof DocumentObjectId);\n\n      var dates = Loki.path('dates').cast(['8/24/2010', 1294541504958]);\n\n      assert.ok(dates[0] instanceof Date);\n      assert.ok(dates[1] instanceof Date);\n\n      var numbers = Loki.path('numbers').cast([152, '31']);\n\n      assert.equal(typeof numbers[0], 'number');\n      assert.equal(typeof numbers[1], 'number');\n\n      var strings = Loki.path('strings').cast(['test', 123]);\n\n      assert.equal(typeof strings[0], 'string');\n      assert.equal('test',strings[0]);\n\n      assert.equal(typeof strings[1], 'string');\n      assert.equal('123', strings[1]);\n\n      var buffers = Loki.path('buffers').cast(['\\0\\0\\0', new Buffer(\"abc\")]);\n\n      assert.ok(buffers[0] instanceof Buffer);\n      assert.ok(buffers[1] instanceof Buffer);\n\n      var nocasts = Loki.path('nocast').cast(['test', 123]);\n\n      assert.equal(typeof nocasts[0], 'string');\n      assert.equal('test', nocasts[0]);\n\n      assert.equal(typeof nocasts[1], 'number');\n      assert.equal(123, nocasts[1]);\n\n      var mixed = Loki.path('mixed').cast(['test', 123, '123', {}, new Date, new DocumentObjectId]);\n\n      assert.equal(typeof mixed[0], 'string');\n      assert.equal(typeof mixed[1], 'number');\n      assert.equal(typeof mixed[2], 'string');\n      assert.equal(typeof mixed[3], 'object');\n      assert.ok(mixed[4] instanceof Date);\n      assert.ok(mixed[5] instanceof DocumentObjectId);\n    });\n\n    it('boolean', function(){\n      var Animal = new Schema({\n          isFerret: { type: Boolean, required: true }\n      });\n\n      assert.strictEqual(Animal.path('isFerret').cast(null), null);\n      assert.equal(false, Animal.path('isFerret').cast(undefined));\n      assert.equal(false, Animal.path('isFerret').cast(false));\n      assert.equal(false, Animal.path('isFerret').cast(0));\n      assert.equal(false, Animal.path('isFerret').cast('0'));\n      assert.equal(true, Animal.path('isFerret').cast({}));\n      assert.equal(true, Animal.path('isFerret').cast(true));\n      assert.equal(true, Animal.path('isFerret').cast(1));\n      assert.equal(true, Animal.path('isFerret').cast('1'));\n    });\n  });\n\n  it('methods declaration', function(){\n    var a = new Schema;\n    a.method('test', function(){});\n    a.method({\n        a: function(){}\n      , b: function(){}\n    });\n    assert.equal(3, Object.keys(a.methods).length);\n  });\n\n  it('static declaration', function(){\n    var a = new Schema;\n    a.static('test', function(){});\n    a.static({\n        a: function(){}\n      , b: function(){}\n      , c: function(){}\n    });\n\n    assert.equal(Object.keys(a.statics).length, 4)\n  });\n\n  describe('setters', function(){\n    it('work', function(){\n      function lowercase (v) {\n        return v.toLowerCase();\n      };\n\n      var Tobi = new Schema({\n          name: { type: String, set: lowercase }\n      });\n\n      assert.equal('woot', Tobi.path('name').applySetters('WOOT'));\n      assert.equal(1, Tobi.path('name').setters.length);\n\n      Tobi.path('name').set(function(v){\n        return v + 'WOOT';\n      });\n\n      assert.equal('wootwoot', Tobi.path('name').applySetters('WOOT'));\n      assert.equal(2, Tobi.path('name').setters.length);\n    });\n\n    it('order', function(){\n      function extract (v, self) {\n        return (v && v._id)\n          ? v._id\n          : v\n      };\n\n      var Tobi = new Schema({\n          name: { type: Schema.ObjectId, set: extract }\n      });\n\n      var id = new DocumentObjectId\n        , sid = id.toString()\n        , _id = { _id: id };\n\n      assert.equal(Tobi.path('name').applySetters(sid, { a: 'b' }).toString(),sid);\n      assert.equal(Tobi.path('name').applySetters(_id, { a: 'b' }).toString(),sid);\n      assert.equal(Tobi.path('name').applySetters(id, { a: 'b' }).toString(),sid);\n    });\n\n    it('scope', function(){\n      function lowercase (v, self) {\n        assert.equal('b', this.a);\n        assert.equal('name', self.path);\n        return v.toLowerCase();\n      };\n\n      var Tobi = new Schema({\n          name: { type: String, set: lowercase }\n      });\n\n      assert.equal('what', Tobi.path('name').applySetters('WHAT', { a: 'b' }));\n    });\n\n    it('casting', function(){\n      function last (v) {\n        assert.equal('number', typeof v);\n        assert.equal(0, v);\n        return 'last';\n      };\n\n      function first (v) {\n        return 0;\n      };\n\n      var Tobi = new Schema({\n          name: { type: String, set: last }\n      });\n\n      Tobi.path('name').set(first);\n      assert.equal('last', Tobi.path('name').applySetters('woot'));\n    });\n\n    describe('string', function(){\n      it('lowercase', function(){\n        var Tobi = new Schema({\n            name: { type: String, lowercase: true }\n        });\n\n        assert.equal('what', Tobi.path('name').applySetters('WHAT'));\n        assert.equal('1977', Tobi.path('name').applySetters(1977));\n      });\n      it('uppercase', function(){\n        var Tobi = new Schema({\n            name: { type: String, uppercase: true }\n        });\n\n        assert.equal('WHAT', Tobi.path('name').applySetters('what'));\n        assert.equal('1977', Tobi.path('name').applySetters(1977));\n      });\n      it('trim', function(){\n        var Tobi = new Schema({\n            name: { type: String, uppercase: true, trim: true }\n        });\n\n        assert.equal('WHAT', Tobi.path('name').applySetters('  what   '));\n        assert.equal('1977', Tobi.path('name').applySetters(1977));\n      });\n    });\n\n    it('applying when none have been defined', function(){\n      var Tobi = new Schema({\n          name: String\n      });\n\n      assert.equal('woot', Tobi.path('name').applySetters('woot'));\n    });\n\n    it('assignment of non-functions throw', function(){\n      var schema = new Schema({ fun: String });\n      var g, s;\n\n      try {\n        schema.path('fun').set(4);\n      } catch (err_) {\n        g = err_;\n      }\n\n      assert.ok(g);\n      assert.equal(g.message,'A setter must be a function.');\n    })\n  });\n\n  describe('getters', function(){\n    it('work', function(){\n      function woot (v) {\n        return v + ' woot';\n      };\n\n      var Tobi = new Schema({\n          name: { type: String, get: woot }\n      });\n\n      assert.equal(1, Tobi.path('name').getters.length);\n      assert.equal('test woot', Tobi.path('name').applyGetters('test'));\n    });\n    it('order', function(){\n      function format (v, self) {\n        return v\n          ? '$' + v\n          : v\n      };\n\n      var Tobi = new Schema({\n          name: { type: Number, get: format }\n      });\n\n      assert.equal('$30', Tobi.path('name').applyGetters(30, { a: 'b' }));\n    });\n    it('scope', function(){\n      function woot (v, self) {\n        assert.equal('b', this.a);\n        assert.equal('name', self.path);\n        return v.toLowerCase();\n      };\n\n      var Tobi = new Schema({\n          name: { type: String, get: woot }\n      });\n\n      assert.equal('yep', Tobi.path('name').applyGetters('YEP', { a: 'b' }));\n    });\n    it('casting', function(){\n      function last (v) {\n        assert.equal('number', typeof v);\n        assert.equal(0, v);\n        return 'last';\n      };\n\n      function first (v) {\n        return 0;\n      };\n\n      var Tobi = new Schema({\n          name: { type: String, get: last }\n      });\n\n      Tobi.path('name').get(first);\n      assert.equal('last', Tobi.path('name').applyGetters('woot'));\n    });\n    it('applying when none have been defined', function(){\n      var Tobi = new Schema({\n          name: String\n      });\n\n      assert.equal('woot', Tobi.path('name').applyGetters('woot'));\n    });\n    it('assignment of non-functions throw', function(){\n      var schema = new Schema({ fun: String });\n      var g, s;\n\n      try {\n        schema.path('fun').get(true);\n      } catch (err_) {\n        g = err_;\n      }\n\n      assert.ok(g);\n      assert.equal(g.message,'A getter must be a function.');\n    })\n    it('auto _id', function(){\n      var schema = new Schema({\n          name: String\n      });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      var schema = new Schema({\n          name: String\n      }, { _id: true });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      var schema = new Schema({\n          name: String\n      }, { _id: false });\n      assert.equal(undefined, schema.path('_id'));\n\n      // old options\n      var schema = new Schema({\n          name: String\n      }, { noId: false });\n      assert.ok(schema.path('_id') instanceof Schema.ObjectId);\n\n      var schema = new Schema({\n          name: String\n      }, { noId: true });\n      assert.equal(undefined, schema.path('_id'));\n    })\n\n    it('auto id', function(){\n      var schema = new Schema({\n          name: String\n      });\n      assert.ok(schema.virtualpath('id') instanceof mongoose.VirtualType);\n\n      var schema = new Schema({\n          name: String\n      }, { id: true });\n      assert.ok(schema.virtualpath('id') instanceof mongoose.VirtualType);\n\n      var schema = new Schema({\n          name: String\n      }, { id: false });\n      assert.equal(undefined, schema.virtualpath('id'));\n\n      // old options\n      var schema = new Schema({\n          name: String\n      }, { noVirtualId: false });\n      assert.ok(schema.virtualpath('id') instanceof mongoose.VirtualType);\n\n      var schema = new Schema({\n          name: String\n      }, { noVirtualId: true });\n      assert.equal(undefined, schema.virtualpath('id'));\n    })\n  });\n\n  describe('hooks', function(){\n    it('registration', function(){\n      var Tobi = new Schema();\n\n      Tobi.pre('save', function(){});\n      assert.equal(1, Tobi.callQueue.length);\n\n      Tobi.post('save', function(){});\n      assert.equal(2, Tobi.callQueue.length);\n\n      Tobi.pre('save', function(){});\n      assert.equal(3, Tobi.callQueue.length);\n    });\n  });\n\n  describe('indexes', function(){\n    describe('definition', function(){\n      it('basic', function(){\n        var Tobi = new Schema({\n            name: { type: String, index: true }\n        });\n\n        assert.equal(true, Tobi.path('name')._index);\n        Tobi.path('name').index({ unique: true });\n        assert.deepEqual(Tobi.path('name')._index, { unique: true });\n        Tobi.path('name').unique(false);\n        assert.deepEqual(Tobi.path('name')._index, { unique: false });\n\n        var T, i;\n\n        T = new Schema({\n            name: { type: String, sparse: true }\n        });\n        assert.deepEqual(T.path('name')._index, { sparse: true });\n\n        T = new Schema({\n            name: { type: String, unique: true }\n        });\n        assert.deepEqual(T.path('name')._index, { unique: true });\n\n        T = new Schema({\n            name: { type: String, expires:  '1.5m' }\n        });\n        assert.deepEqual(T.path('name')._index, { expireAfterSeconds: 90 });\n\n        T = new Schema({\n            name: { type: String, expires:  200 }\n        });\n        assert.deepEqual(T.path('name')._index, { expireAfterSeconds: 200 });\n\n        T = new Schema({\n            name: { type: String, sparse: true, unique: true }\n        });\n        assert.deepEqual(T.path('name')._index, { sparse: true, unique: true });\n\n        T = new Schema({\n            name: { type: String, unique: true, sparse: true }\n        });\n        i = T.path('name')._index;\n        assert.equal(true, i.unique);\n        assert.equal(true, i.sparse);\n\n        T = new Schema({\n            name: { type: String, index: { sparse: true, unique: true, expireAfterSeconds: 65 }}\n        });\n        i = T.path('name')._index;\n        assert.equal(true, i.unique);\n        assert.equal(true, i.sparse);\n        assert.equal(65, i.expireAfterSeconds);\n\n        T = new Schema({\n            name: { type: String, index: { sparse: true, unique: true, expires: '24h' }}\n        });\n        i = T.path('name')._index;\n        assert.equal(true, i.unique);\n        assert.equal(true, i.sparse);\n        assert.equal(60*60*24, i.expireAfterSeconds);\n\n      })\n      it('compound', function(){\n        var Tobi = new Schema({\n            name: { type: String, index: true }\n          , last: { type: Number, sparse: true }\n          , nope: { type: String, index: { background: false }}\n        });\n\n        Tobi.index({ firstname: 1, last: 1 }, { unique: true, expires: '1h' });\n        Tobi.index({ firstname: 1, nope: 1 }, { unique: true, background: false });\n\n        assert.deepEqual(Tobi.indexes(), [\n            [{ name: 1 }, { background: true }]\n          , [{ last: 1 }, { sparse: true, background :true }]\n          , [{ nope: 1 }, { background : false}]\n          , [{ firstname: 1, last: 1}, {unique: true, expireAfterSeconds: 60*60, background: true }]\n          , [{ firstname: 1, nope: 1 }, { unique: true, background: false }]\n        ]);\n      });\n    });\n  });\n\n  describe('plugins', function(){\n    var Tobi = new Schema\n      , called = false;\n\n    Tobi.plugin(function(schema){\n      assert.equal(schema, Tobi);\n      called = true;\n    });\n\n    assert.equal(true, called);\n  });\n\n  describe('options', function(){\n    it('defaults are set', function(){\n      var Tobi = new Schema();\n\n      assert.equal('object', typeof Tobi.options);\n      assert.equal(true, Tobi.options.safe);\n      assert.equal(true, Tobi.options.strict);\n      assert.equal(false, Tobi.options.capped);\n      assert.equal('__v', Tobi.options.versionKey);\n      assert.equal(null, Tobi.options.shardKey);\n      assert.equal(null, Tobi.options.read);\n      assert.equal(true, Tobi.options._id);\n    });\n\n    it('setting', function(){\n      var Tobi = new Schema({}, { collection: 'users' });\n\n      Tobi.set('a', 'b');\n      Tobi.set('safe', false);\n      assert.equal('users', Tobi.options.collection);\n\n      assert.equal('b', Tobi.options.a);\n      assert.equal(Tobi.options.safe, false);\n      assert.equal(null, Tobi.options.read);\n\n      var tags = [{ x: 1 }];\n\n      Tobi.set('read', 'n');\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('nearest', Tobi.options.read.mode);\n\n      Tobi.set('read', 'n', tags);\n      assert.equal('nearest', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi.set('read', ['n', tags]);\n      assert.equal('nearest', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'p' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primary', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['p', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primary', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'primary' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primary', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['primary', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primary', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 's' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondary', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['s', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondary', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'secondary' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondary', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['secondary', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondary', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'pp' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primaryPrefered', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['pp', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primaryPrefered', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'primaryPrefered'});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primaryPrefered', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['primaryPrefered', tags]});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('primaryPrefered', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'sp' });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondaryPrefered', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['sp', tags] });\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondaryPrefered', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'secondaryPrefered'});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondaryPrefered', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['secondaryPrefered', tags]});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('secondaryPrefered', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'n'});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('nearest', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['n', tags]});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('nearest', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n\n      Tobi = Schema({}, { read: 'nearest'});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('nearest', Tobi.options.read.mode);\n\n      Tobi = Schema({}, { read: ['nearest', tags]});\n      assert.ok(Tobi.options.read instanceof ReadPref);\n      assert.equal('nearest', Tobi.options.read.mode);\n      assert.ok(Array.isArray(Tobi.options.read.tags));\n      assert.equal(1, Tobi.options.read.tags.length);\n      assert.equal(1, Tobi.options.read.tags[0].x);\n    });\n  });\n\n  describe('virtuals', function(){\n    it('works', function(){\n      var Contact = new Schema({\n          firstName: String\n        , lastName: String\n      });\n\n      Contact\n      .virtual('fullName')\n      .get(function () {\n        return this.get('firstName') + ' ' + this.get('lastName');\n      })\n      .set(function (fullName) {\n        var split = fullName.split(' ');\n        this.set('firstName', split[0]);\n        this.set('lastName', split[1]);\n      });\n\n      assert.ok(Contact.virtualpath('fullName') instanceof VirtualType);\n    });\n\n    describe('id', function(){\n      it('default creation of id can be overridden (gh-298)', function(){\n        assert.doesNotThrow(function () {\n          new Schema({ id: String });\n        });\n      });\n      it('disabling', function(){\n        var schema = new Schema({ name: String }, { noVirtualId: true });\n        assert.strictEqual(undefined, schema.virtuals.id);\n      });\n    });\n\n    describe('getter', function(){\n      it('scope', function(){\n        var Tobi = new Schema;\n\n        Tobi.virtual('name').get(function (v, self) {\n          assert.equal('b', this.a);\n          assert.equal('name', self.path);\n          return v.toLowerCase();\n        })\n\n        assert.equal('yep', Tobi.virtualpath('name').applyGetters('YEP', { a: 'b' }));\n      })\n    })\n\n    describe('setter', function(){\n      it('scope', function(){\n        var Tobi = new Schema;\n\n        Tobi.virtual('name').set(function (v, self) {\n          assert.equal('b', this.a);\n          assert.equal('name', self.path);\n          return v.toLowerCase();\n        })\n\n        assert.equal('yep', Tobi.virtualpath('name').applySetters('YEP', { a: 'b' }));\n      })\n    })\n  });\n\n  describe('other contexts', function(){\n    it('work', function(){\n      var str = 'code = {' +\n        '  name: String' +\n        ', arr1: Array ' +\n        ', arr2: { type: [] }' +\n        ', date: Date  ' +\n        ', num: { type: Number }' +\n        ', bool: Boolean' +\n        ', nest: { sub: { type: {}, required: true }}' +\n        '}';\n\n      var script = vm.createScript(str, 'testSchema.vm');\n      var sandbox = { code: null };\n      script.runInNewContext(sandbox);\n\n      var Ferret = new Schema(sandbox.code);\n      assert.ok(Ferret.path('nest.sub') instanceof SchemaTypes.Mixed);\n      assert.ok(Ferret.path('name') instanceof SchemaTypes.String);\n      assert.ok(Ferret.path('arr1') instanceof SchemaTypes.Array);\n      assert.ok(Ferret.path('arr2') instanceof SchemaTypes.Array);\n      assert.ok(Ferret.path('date') instanceof SchemaTypes.Date);\n      assert.ok(Ferret.path('num') instanceof SchemaTypes.Number);\n      assert.ok(Ferret.path('bool') instanceof SchemaTypes.Boolean);\n    });\n  });\n\n  describe('#add()', function(){\n    it('does not polute existing paths', function(){\n      var o = { name: String }\n      var s = new Schema(o);\n      s.add({ age: Number }, 'name.');\n      assert.equal(false, ('age' in o.name));\n    });\n\n    it('merging nested objects (gh-662)', function(done){\n      var db = start();\n\n      var MergedSchema = new Schema({\n        a: {\n          foo: String\n        }\n      });\n\n      MergedSchema.add({\n        a: {\n          b: {\n            bar: String\n          }\n        }\n      });\n\n      mongoose.model('Merged', MergedSchema);\n\n      var Merged = db.model('Merged', 'merged_' + Math.random());\n\n      var merged = new Merged({\n        a: {\n            foo: 'baz'\n          , b: {\n              bar: 'qux'\n            }\n        }\n      });\n\n      merged.save(function(err) {\n        assert.ifError(err);\n        Merged.findById(merged.id, function(err, found) {\n          db.close();\n          assert.ifError(err);\n          assert.equal(found.a.foo,'baz');\n          assert.equal(found.a.b.bar,'qux');\n          done();\n        });\n      });\n    })\n  });\n\n  it('debugging msgs', function(){\n    var err;\n    try {\n      new Schema({ name: { first: null } })\n    } catch (e) {\n      err = e;\n    }\n    assert.equal(err.message,'Invalid value for schema path `name.first`')\n    try {\n      new Schema({ age: undefined })\n    } catch (e) {\n      err = e;\n    }\n    assert.equal(err.message, 'Invalid value for schema path `age`')\n  });\n\n  describe('construction', function(){\n    it('array of object literal missing a type is interpreted as DocumentArray', function(){\n      var goose = new mongoose.Mongoose;\n      var s = new Schema({\n          arr: [\n            { something: { type: String } }\n          ]\n      });\n      assert.ok(s.path('arr') instanceof SchemaTypes.DocumentArray);\n      var M = goose.model('objectliteralschema', s);\n      var m = new M({ arr: [ { something: 'wicked this way comes' }] });\n      assert.equal('wicked this way comes', m.arr[0].something);\n      assert.ok(m.arr[0]._id);\n    });\n\n    it('array of object literal with type.type is interpreted as DocumentArray', function(){\n      var goose = new mongoose.Mongoose;\n      var s = new Schema({\n          arr: [\n            { type: { type: String } }\n          ]\n      });\n      assert.ok(s.path('arr') instanceof SchemaTypes.DocumentArray);\n      var M = goose.model('objectliteralschema2', s);\n      var m = new M({ arr: [ { type: 'works' }] });\n      assert.equal('works', m.arr[0].type);\n      assert.ok(m.arr[0]._id);\n    });\n\n    it('of nested schemas should throw (gh-700)', function(){\n      var a = new Schema({ title: String })\n        , err\n\n      try {\n        new Schema({ blah: Boolean, a: a });\n      } catch (err_) {\n        err = err_;\n      }\n\n      assert.ok(err);\n      assert.ok(/Did you try nesting Schemas/.test(err.message));\n    });\n\n  });\n\n  describe('conflicting property names', function(){\n    it('throws', function(){\n      var child = new Schema({ name: String });\n\n      assert.throws(function(){\n        new Schema({\n            on: String\n          , child: [child]\n        });\n      }, /`on` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            options: String\n        });\n      }, /`options` may not be used as a schema pathname/);\n\n      assert.doesNotThrow(function(){\n        new Schema({\n            model: String\n        });\n      });\n\n      assert.throws(function(){\n        new Schema({\n           collection: String\n        });\n      }, /`collection` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            schema: String\n        });\n      }, /`schema` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            db: String\n        });\n      }, /`db` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            modelName: String\n        });\n      }, /`modelName` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            isNew: String\n        });\n      }, /`isNew` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            errors: String\n        });\n      }, /`errors` may not be used as a schema pathname/);\n\n      assert.throws(function(){\n        new Schema({\n            init: String\n        });\n      }, /`init` may not be used as a schema pathname/);\n\n      assert.doesNotThrow(function(){\n        Schema({ child: [{parent: String}] });\n      });\n\n      assert.doesNotThrow(function(){\n        Schema({ child: [{parentArray: String}] });\n      });\n\n    })\n  })\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":45216}]],"length":45216}
