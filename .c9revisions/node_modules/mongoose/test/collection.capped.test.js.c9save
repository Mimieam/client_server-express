{"ts":1352708284425,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/**\n * Module dependencies.\n */\n\nvar start = require('./common')\n  , mongoose = start.mongoose\n  , assert = require('assert')\n  , Schema = mongoose.Schema\n  , random = require('../lib/utils').random\n\n/**\n * setup\n */\n\nvar capped = new Schema({ key: 'string', val: 'number' });\ncapped.set('capped', { size: 1000 });\n\nvar coll = 'capped_' + random();\n\n/**\n * Test.\n */\n\ndescribe('collections: capped:', function(){\n  it('schemas should have option size', function(){\n    assert.ok(capped.options.capped);\n    assert.equal(1000, capped.options.capped.size);\n  })\n  it('creation', function(done){\n    var db = start();\n    var Capped = db.model('Capped', capped, coll);\n    Capped.collection.isCapped(function (err, isCapped) {\n      assert.ifError(err);\n      assert.ok(isCapped, 'should create a capped collection');\n\n      // use the existing capped collection in the db (no coll creation)\n      var Capped2 = db.model('Capped2', capped, coll);\n      Capped2.collection.isCapped(function (err, isCapped) {\n        db.close();\n        assert.ifError(err);\n        assert.ok(isCapped, 'should reuse the capped collection in the db');\n        assert.equal(Capped.collection.name, Capped2.collection.name);\n        done();\n      });\n    });\n  });\n  it('creation using a number', function(done){\n    var db = start();\n    var schema = new Schema({ key: 'string' }, { capped: 100 });\n    var Capped = db.model('Capped3', schema);\n    Capped.collection.options(function (err, options) {\n      assert.ifError(err);\n      assert.ok(options.capped, 'should create a capped collection');\n      assert.equal(100, options.size);\n      var s = '';\n      for (var i = 0; i < 3800; ++i) s+='A';\n      Capped.create({ key: s }, function (err, doc) {\n        assert.ifError(err);\n        var id = doc.id;\n        Capped.count(function (err, count) {\n          assert.ifError(err);\n          assert.equal(1, count);\n          var c = new Capped({ key: s });\n          c.save(function (err, doc, num) {\n            assert.ifError(err);\n            assert.equal(1, num);\n            Capped.find(function (err, docs) {\n              assert.ifError(err);\n              assert.equal(1, docs.length);\n              c = docs[0];\n              assert.notEqual(id, c.id);\n              c.key = c.key + s;\n              c.save(function (err) {\n                assert.ok(err);\n                c.remove(function (err) {\n                  db.close();\n                  assert.ok(err);\n                  assert.equal(10101, err.code);\n                  done();\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  })\n  it('attempting to use existing non-capped collection as capped emits error', function(done){\n    var db = start();\n    var opts = { safe: true }\n    var conn = 'capped_existing_'+random();\n\n    db.on('open', function () {\n      db.db.createCollection(conn, opts, function (err) {\n        if (err) db.close();\n        assert.ifError(err);\n\n        var timer;\n\n        db.on('error', function (err) {\n          clearTimeout(timer);\n          db.close();\n          assert.ok(/non-capped collection exists/.test(err));\n          done();\n        });\n\n        var C = db.model('CappedExisting', capped, conn);\n        timer = setTimeout(function () {\n          db.close();\n          throw new Error('capped test timeout');\n        }, 900);\n      });\n    });\n  })\n})\n"]],"start1":0,"start2":0,"length1":0,"length2":3393}]],"length":3393}
